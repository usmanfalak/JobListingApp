"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initChannelMessagingFunctions = void 0;
const identifierUtils_1 = require("./identifierUtils");
const sessionStorageUtils_1 = require("./sessionStorageUtils");
const navTreeUtils_1 = require("./navTreeUtils");
// @ts-ignore
const jquery_1 = __importDefault(require("jquery"));
const lodash_1 = __importDefault(require("lodash"));
const outlineUtils_1 = require("./outlineUtils");
const cssFunctions_1 = require("./cssFunctions");
const constantsAndTypes_1 = require("./constantsAndTypes");
const changeItemFunctions_1 = require("./changeItemFunctions");
const tempoElement_1 = require("./tempoElement");
const editTextUtils_1 = require("./editTextUtils");
const DebounceExecutor_1 = require("../utils/DebounceExecutor");
const domUtils_1 = require("./domUtils");
const PIXELS_TO_MOVE_BEFORE_DRAG = 20;
const IMMEDIATELY_REMOVE_POINTER_LOCK = 'IMMEDIATELY_REMOVE_POINTER_LOCK';
const LAST_NAV_TREE_REFRESH_TIME = 'LAST_NAV_TREE_REFRESH_TIME';
const LAST_SENT_HOVERED_ELEMENT_KEY = 'LAST_SENT_HOVERED_ELEMENT_KEY';
const html_to_image_1 = require("html-to-image");
const MESSAGE_THROTTLE_MS = 50;
// TODO: Change all of this to be a react wrapper library
const initChannelMessagingFunctions = () => {
    // Prevent multiple initializations
    // @ts-ignore
    if (window.tempoInitialized) {
        return;
    }
    // @ts-ignore
    window.tempoInitialized = true;
    (0, changeItemFunctions_1.resetIntermediateClassesForSliderInstantUpdate)();
    // All processes that involves updating the UI should use this runner to avoid triggering a cascade of updates
    let globalUIUpdateRunner = domUtils_1.defaultUIUpdateRunner;
    // Create throttled post message functions per message type
    const throttledPostMessageFunctions = new Map();
    const throttledPostMessage = (parentPort, message) => {
        const messageType = message.id;
        if (!throttledPostMessageFunctions.has(messageType)) {
            const throttledFn = lodash_1.default.throttle((msg) => parentPort.postMessage(msg), MESSAGE_THROTTLE_MS, { leading: true, trailing: true });
            throttledPostMessageFunctions.set(messageType, throttledFn);
        }
        const throttledFn = throttledPostMessageFunctions.get(messageType);
        throttledFn === null || throttledFn === void 0 ? void 0 : throttledFn(message);
    };
    // only sends message for HOVERED_ELEMENT_KEY when value changes
    const sendHoveredElementKeyMessage = (parentPort, elementKey) => {
        const lastSentKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(LAST_SENT_HOVERED_ELEMENT_KEY);
        // Only send message if the value has changed
        if (lastSentKey !== elementKey) {
            parentPort.postMessage({
                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.HOVERED_ELEMENT_KEY,
                elementKey: elementKey,
            });
            (0, sessionStorageUtils_1.setMemoryStorageItem)(LAST_SENT_HOVERED_ELEMENT_KEY, elementKey);
        }
    };
    // @ts-ignore
    String.prototype.hashCode = function () {
        var hash = 0, i, chr;
        if (this.length === 0)
            return hash;
        for (i = 0; i < this.length; i++) {
            chr = this.charCodeAt(i);
            hash = (hash << 5) - hash + chr;
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    };
    // We want to make event listeners non-passive, and to do so have to check
    // that browsers support EventListenerOptions in the first place.
    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
    let passiveSupported = false;
    const makePassiveEventOption = () => {
        try {
            const options = {
                get passive() {
                    // This function will be called when the browser
                    //   attempts to access the passive property.
                    passiveSupported = true;
                    return false;
                },
            };
            return options;
        }
        catch (err) {
            passiveSupported = false;
            return passiveSupported;
        }
    };
    /**
     * Taken from: https://stackoverflow.com/questions/3219758/detect-changes-in-the-dom
     *
     * Returns the function to disconnect the observer
     */
    const observeDOM = (function () {
        // @ts-ignore
        var MutationObserver = 
        // @ts-ignore
        window.MutationObserver || window.WebKitMutationObserver;
        return function (objs, callback) {
            const filteredObjs = objs.filter((obj) => obj && obj.nodeType === 1);
            if (filteredObjs.length === 0) {
                return domUtils_1.defaultUIUpdateRunner;
            }
            var mutationObserver;
            const uiUpdateRunner = (innerScope) => {
                // Pause the observer
                if (mutationObserver) {
                    mutationObserver.disconnect();
                }
                innerScope();
                // Resume the observer
                if (mutationObserver) {
                    filteredObjs.forEach((obj) => {
                        mutationObserver.observe(obj, {
                            childList: true,
                            subtree: true,
                            attributes: true,
                            attributeOldValue: true,
                        });
                    });
                }
            };
            if (MutationObserver) {
                mutationObserver = new MutationObserver(callback);
                filteredObjs.forEach((obj) => {
                    // have the observer observe foo for changes in children
                    mutationObserver.observe(obj, {
                        childList: true,
                        subtree: true,
                        attributes: true,
                        attributeOldValue: true,
                    });
                });
            }
            // browser support fallback
            // @ts-ignore
            else if (window.addEventListener) {
                filteredObjs.forEach((obj) => {
                    obj.addEventListener('DOMNodeInserted', callback, false);
                    obj.addEventListener('DOMNodeRemoved', callback, false);
                });
            }
            return uiUpdateRunner;
        };
    })();
    /**
     * When selecting in normal mode (not meta key), can select one level down, a sibling
     * or a parent of the selected element
     */
    const getSelectableNavNode = (e) => {
        var _a;
        const selectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);
        const selectedElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);
        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE);
        // Move up the tree until you find the first valid nav node
        let firstNavNode = null;
        let searchNode = e.target;
        while (searchNode && !firstNavNode) {
            firstNavNode =
                elementKeyToNavNode[(0, identifierUtils_1.getElementKeyFromNode)(searchNode) || ''];
            searchNode = searchNode.parentElement;
        }
        if (!firstNavNode) {
            return constantsAndTypes_1.SELECT_OR_HOVER_STORYBOARD;
        }
        const isNavNodeMatch = (navTreeNode) => {
            var _a, _b, _c, _d;
            if (selectedElement.isEmpty()) {
                // This function cannot be called if there is no selected element, see code logic below the function
                throw Error('No selected element when isNavNodeMatch called');
            }
            if (!navTreeNode) {
                return false;
            }
            // If there is no codebase ID it should not be selectable as there is nothing we can do with it
            if (!navTreeNode.tempoElement.codebaseId.startsWith('tempo-') ||
                navTreeNode.tempoElement.codebaseId === navTreeUtils_1.SKIP_ROOT_CODEBASE_ID) {
                return false;
            }
            // If it matches, we already passed all possible children, so re-select it
            if (selectedElement.isEqual(navTreeNode.tempoElement)) {
                return true;
            }
            // Any parent is ok to select
            if (navTreeNode.tempoElement.isParentOf(selectedElement)) {
                return true;
            }
            // Check parents
            // Pick the first parent with a codebase ID
            let parent = navTreeNode.parent;
            while (parent && !parent.tempoElement.codebaseId.startsWith('tempo-')) {
                parent = parent.parent;
            }
            // One level down
            if ((_a = parent === null || parent === void 0 ? void 0 : parent.tempoElement) === null || _a === void 0 ? void 0 : _a.isEqual(selectedElement)) {
                return true;
            }
            // Sibling of any parent
            const selectedNode = elementKeyToNavNode[selectedElement.getKey()];
            if (selectedNode &&
                ((_d = (_c = (_b = navTreeNode.parent) === null || _b === void 0 ? void 0 : _b.children) === null || _c === void 0 ? void 0 : _c.includes) === null || _d === void 0 ? void 0 : _d.call(_c, selectedNode))) {
                return true;
            }
            return false;
        };
        let foundNavNode = null;
        let searchNavNode = firstNavNode;
        while (searchNavNode) {
            if (!selectedElement.isEmpty() && !selectedElement.isStoryboard()) {
                // If there is a selected element key loop from this element up the stack to find the element that is the direct child
                // of the expected selected element, so that you can only hover one level deeper than you've selected
                if (isNavNodeMatch(searchNavNode)) {
                    foundNavNode = searchNavNode;
                    // Exit the loop as we found the node that matches
                    break;
                }
            }
            else {
                // If there is no selected element key, or the selection is the storyboard itself, loop up to the top-most element with a codebase ID
                if ((_a = searchNavNode.tempoElement.codebaseId) === null || _a === void 0 ? void 0 : _a.startsWith('tempo-')) {
                    foundNavNode = searchNavNode;
                    // Note: we do not exit the loop here as we want to keep searching for the top-most element
                }
            }
            searchNavNode = searchNavNode.parent;
        }
        return foundNavNode || null;
    };
    const onPointerOver = (e, parentPort, storyboardId, selectBottomMostElement) => {
        const passedThrough = passThroughEventsIfNeeded(e, parentPort, storyboardId);
        const editingTextInfo = (0, editTextUtils_1.getEditingInfo)();
        // Allow on pointer over events if editing (so we can click out)
        if (e.altKey || (passedThrough && !editingTextInfo)) {
            return;
        }
        if ((0, sessionStorageUtils_1.getMemoryStorageItem)('mouseDragContext')) {
            return;
        }
        const currentHoveredKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY);
        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};
        let hoveredNavNode;
        if (e.metaKey || e.ctrlKey || selectBottomMostElement) {
            const elementKey = (0, identifierUtils_1.getElementKeyFromNode)(e.target);
            hoveredNavNode = elementKeyToNavNode[elementKey];
            // Special case -> this is the top-most node so it should trigger a hover on the storyboard
            if (!hoveredNavNode && e.target.parentNode === document.body) {
                hoveredNavNode = constantsAndTypes_1.SELECT_OR_HOVER_STORYBOARD;
            }
        }
        else {
            hoveredNavNode = getSelectableNavNode(e);
        }
        const currentSelectedKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);
        const currentSelectedElement = tempoElement_1.TempoElement.fromKey(currentSelectedKey);
        // If the user is holding shift, only allow selecting siblings
        if (e.shiftKey && hoveredNavNode && currentSelectedKey) {
            // Trying to select the entire storyboard, allow only if the other selected element is also a storyboard
            if (typeof hoveredNavNode === 'string' &&
                !currentSelectedElement.isStoryboard()) {
                hoveredNavNode = null;
            }
            if (typeof hoveredNavNode !== 'string' &&
                !(hoveredNavNode === null || hoveredNavNode === void 0 ? void 0 : hoveredNavNode.tempoElement.isSiblingOf(currentSelectedElement))) {
                hoveredNavNode = null;
            }
        }
        if (!hoveredNavNode) {
            if (currentHoveredKey !== null) {
                (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY, null);
                sendHoveredElementKeyMessage(parentPort, null);
                (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
            }
            return;
        }
        if (typeof hoveredNavNode === 'string') {
            if (hoveredNavNode === constantsAndTypes_1.SELECT_OR_HOVER_STORYBOARD) {
                const storyboardKey = tempoElement_1.TempoElement.forStoryboard(storyboardId).getKey();
                if (currentHoveredKey !== storyboardKey) {
                    (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY, storyboardKey);
                    sendHoveredElementKeyMessage(parentPort, storyboardKey);
                    (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
                }
            }
            return;
        }
        const tempoElementKey = hoveredNavNode.tempoElement.getKey();
        if (currentHoveredKey !== tempoElementKey) {
            sendHoveredElementKeyMessage(parentPort, tempoElementKey);
            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY, tempoElementKey);
            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
        }
    };
    const clearHoveredElements = (parentPort, storyboardId) => {
        const currentHoveredKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY);
        if (!currentHoveredKey) {
            return;
        }
        sendHoveredElementKeyMessage(parentPort, null);
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY, null);
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    };
    const onPointerMove = (e, parentPort, storyboardId) => __awaiter(void 0, void 0, void 0, function* () {
        passThroughEventsIfNeeded(e, parentPort, storyboardId);
        // If no buttons are pressed the drag end event may not have correctly triggered
        // reset the drag state
        let mouseDragData = (0, sessionStorageUtils_1.getMemoryStorageItem)('mouseDragContext');
        if (!e.buttons && mouseDragData) {
            (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', null);
            if (mouseDragData === null || mouseDragData === void 0 ? void 0 : mouseDragData.dragging) {
                parentPort.postMessage({
                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.DRAG_CANCEL_EVENT,
                    event: {},
                });
            }
            mouseDragData = null;
        }
        const importantFields = {
            pageX: e.pageX,
            pageY: e.pageY,
            clientX: e.clientX,
            clientY: e.clientY,
        };
        (0, sessionStorageUtils_1.setMemoryStorageItem)('mousePos', importantFields);
        throttledPostMessage(parentPort, {
            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MOUSE_MOVE_EVENT,
            event: importantFields,
        });
        if (mouseDragData && !mouseDragData.dragging) {
            const zoomPerc = (0, sessionStorageUtils_1.getMemoryStorageItem)('zoomPerc') || 1;
            const totalMovementPixels = Math.abs(mouseDragData.pageX - e.pageX) +
                Math.abs(mouseDragData.pageY - e.pageY);
            // Start the drag event if the user has moved enough
            if (totalMovementPixels >= PIXELS_TO_MOVE_BEFORE_DRAG / zoomPerc) {
                // Reselect the parent if there was one to select
                if (mouseDragData.parentSelectedElementKey) {
                    const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};
                    const navNodeToSelect = elementKeyToNavNode[mouseDragData.parentSelectedElementKey];
                    if (navNodeToSelect) {
                        parentPort.postMessage({
                            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,
                            elementKey: mouseDragData.parentSelectedElementKey,
                            outerHTML: (0, changeItemFunctions_1.getFullHtmlWithElement)([
                                mouseDragData.parentSelectedElementKey,
                            ]),
                        });
                        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, mouseDragData.parentSelectedElementKey);
                    }
                }
                const aiContextSelection = (0, sessionStorageUtils_1.getMemoryStorageItem)('aiContext');
                // Don't enable dragging if the AI context is enabled
                if (!aiContextSelection) {
                    (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', Object.assign(Object.assign({}, mouseDragData), { dragging: true }));
                    const selectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);
                    // Trigger the drag start event
                    parentPort.postMessage({
                        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.DRAG_START_EVENT,
                        event: mouseDragData,
                        outerHTML: (0, changeItemFunctions_1.getFullHtmlWithElement)([selectedElementKey]),
                    });
                    const bodyObject = (0, jquery_1.default)('body').get(0);
                    // HACK: March 8, 2024
                    // Without this workaround events stay inside the iframe so it's not possible to
                    // track mouse movements outside the iframe when clicking & dragging.
                    // Set the pointer lock and immediately remove it so that
                    // the events start to propagate upwards in the outer application.
                    (0, sessionStorageUtils_1.setMemoryStorageItem)(IMMEDIATELY_REMOVE_POINTER_LOCK, true);
                    yield (bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.requestPointerLock());
                }
            }
        }
        if ((0, sessionStorageUtils_1.getMemoryStorageItem)('mouseDragContext')) {
            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
        }
    });
    const getParentDomElementForNavNode = (navNode) => {
        if (!navNode) {
            return null;
        }
        if (!(navNode === null || navNode === void 0 ? void 0 : navNode.isComponent)) {
            const childDomElement = (0, identifierUtils_1.getNodeForElementKey)(navNode.tempoElement.getKey());
            return childDomElement === null || childDomElement === void 0 ? void 0 : childDomElement.parentElement;
        }
        // This is the list of real DOM elements that are at the top level of this component
        const elementKeyToLookupList = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_LOOKUP_LIST) || {};
        const lookupList = elementKeyToLookupList[navNode.tempoElement.getKey()] || [];
        let childDomElement;
        lookupList.forEach((lookupElementKey) => {
            if (childDomElement) {
                return;
            }
            childDomElement = (0, identifierUtils_1.getNodeForElementKey)(lookupElementKey);
        });
        return childDomElement === null || childDomElement === void 0 ? void 0 : childDomElement.parentElement;
    };
    const onPointerDown = (e, parentPort, storyboardId) => {
        // This variable determines which button was used
        // 1 -> left, 2 -> middle, 3 -> right
        if (e.which !== 1) {
            return;
        }
        // Allow the edit dynamic text button to be clicked
        if ((0, identifierUtils_1.hasClass)(e.target, identifierUtils_1.EDIT_TEXT_BUTTON)) {
            return;
        }
        const passedThrough = passThroughEventsIfNeeded(e, parentPort, storyboardId);
        if (passedThrough) {
            return;
        }
        const selectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);
        const selectedElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);
        const selectedNavNode = onSelectElement(e, parentPort, storyboardId);
        const useSelectedIfDragging = !selectedElement.isEmpty() &&
            selectedElement.isParentOf(selectedNavNode === null || selectedNavNode === void 0 ? void 0 : selectedNavNode.tempoElement);
        let offsetX, offsetY;
        if (selectedNavNode === null || selectedNavNode === void 0 ? void 0 : selectedNavNode.pageBoundingBox) {
            offsetX =
                selectedNavNode.pageBoundingBox.pageX +
                    selectedNavNode.pageBoundingBox.width / 2 -
                    e.pageX;
            offsetY =
                selectedNavNode.pageBoundingBox.pageY +
                    selectedNavNode.pageBoundingBox.height / 2 -
                    e.pageY;
        }
        const importantFields = {
            pageX: e.pageX,
            pageY: e.pageY,
            // The difference between where the user clicked and the center of the element
            offsetX,
            offsetY,
            // Used to reselect the parent if the user starts to move
            parentSelectedElementKey: useSelectedIfDragging
                ? selectedElementKey
                : null,
        };
        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};
        // Get the parent element (actual DOM element) that this node is being dragged inside
        // To do this pick one child element that is being dragged (can be multiple children if the node being dragged is a component),
        // and get its parent in the DOM
        const navNodeToUseForDragging = useSelectedIfDragging
            ? elementKeyToNavNode[selectedElementKey]
            : selectedNavNode;
        const parentDomElement = getParentDomElementForNavNode(navNodeToUseForDragging);
        if (parentDomElement) {
            importantFields['selectedParentDisplay'] = (0, cssFunctions_1.cssEval)(parentDomElement, 'display');
            importantFields['selectedParentFlexDirection'] = (0, cssFunctions_1.cssEval)(parentDomElement, 'flex-direction');
        }
        const aiContextSelection = (0, sessionStorageUtils_1.getMemoryStorageItem)('aiContext');
        // Don't enable dragging if the AI context is enabled
        if (!aiContextSelection) {
            (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', importantFields);
        }
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    };
    const onPointerUp = (e, parentPort, storyboardId) => {
        passThroughEventsIfNeeded(e, parentPort, storyboardId);
        const mouseDragData = (0, sessionStorageUtils_1.getMemoryStorageItem)('mouseDragContext');
        (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', null);
        if (mouseDragData === null || mouseDragData === void 0 ? void 0 : mouseDragData.dragging) {
            parentPort.postMessage({
                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.DRAG_END_EVENT,
                event: {},
            });
        }
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    };
    const onSelectElement = (e, parentPort, storyboardId) => {
        const driveModeEnabled = !!(0, sessionStorageUtils_1.getSessionStorageItem)('driveModeEnabled', storyboardId);
        if (driveModeEnabled) {
            return null;
        }
        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};
        let selectedNavNode;
        if (e.metaKey || e.ctrlKey) {
            const elementKey = (0, identifierUtils_1.getElementKeyFromNode)(e.target);
            selectedNavNode = elementKeyToNavNode[elementKey];
            // Special case -> this is the top-most node so it should trigger a select on the storyboard
            if (!selectedNavNode && e.target.parentNode === document.body) {
                selectedNavNode = constantsAndTypes_1.SELECT_OR_HOVER_STORYBOARD;
            }
        }
        else {
            selectedNavNode = getSelectableNavNode(e);
        }
        const currentSelectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);
        // If this is not a valid nav node, it's not something we track - deselect all
        if (!selectedNavNode) {
            if (currentSelectedElementKey) {
                parentPort.postMessage({
                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,
                    elementKey: null,
                });
                (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, null);
                (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
            }
            return null;
        }
        const currentSelectedElement = tempoElement_1.TempoElement.fromKey(currentSelectedElementKey);
        const currentMultiSelectedKeys = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS) || [];
        let newSelectedElement = typeof selectedNavNode === 'string'
            ? tempoElement_1.TempoElement.forStoryboard(storyboardId)
            : selectedNavNode.tempoElement;
        let newMultiSelectKeys = [];
        // If the user is holding shift, check if we can multi-select (something has to be already selected)
        // Note: this logic generally matches the logic in the iframe slice on tempo-web
        if (e.shiftKey && currentSelectedElementKey) {
            // First check if we are deselecting
            const elementToDeselect = currentMultiSelectedKeys
                .map((elementKey) => tempoElement_1.TempoElement.fromKey(elementKey))
                .find((element) => {
                return (element.isParentOf(newSelectedElement) ||
                    element.isEqual(newSelectedElement));
            });
            if (elementToDeselect) {
                newMultiSelectKeys = currentMultiSelectedKeys.filter((elementKey) => {
                    return elementKey !== elementToDeselect.getKey();
                });
                // Pick a new element to be the main selected element
                // Note, if the length is 1, there is logic further down to handle that case explicitly (to exit multiselect mode)
                if (elementToDeselect.isEqual(currentSelectedElement) &&
                    newMultiSelectKeys.length > 1) {
                    parentPort.postMessage({
                        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,
                        elementKey: newMultiSelectKeys[0],
                        outerHTML: (0, changeItemFunctions_1.getFullHtmlWithElement)([newMultiSelectKeys[0]]),
                    });
                    (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, newMultiSelectKeys[0]);
                }
                // Check if we can add this element
            }
            else if (currentSelectedElement.isSiblingOf(newSelectedElement)) {
                if (currentMultiSelectedKeys === null || currentMultiSelectedKeys === void 0 ? void 0 : currentMultiSelectedKeys.length) {
                    newMultiSelectKeys = currentMultiSelectedKeys.concat([
                        newSelectedElement.getKey(),
                    ]);
                }
                else {
                    newMultiSelectKeys = [
                        currentSelectedElementKey,
                        newSelectedElement.getKey(),
                    ];
                }
            }
            else {
                // This case the user is trying to multiselect but it's not something that's allowed, just return but don't make any changes
                return null;
            }
        }
        // In multiselect mode, set the necessary values
        if (newMultiSelectKeys.length > 1) {
            parentPort.postMessage({
                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MULTI_SELECTED_ELEMENT_KEYS,
                elementKeys: newMultiSelectKeys,
                outerHTMLs: (0, changeItemFunctions_1.getFullHtmlWithElement)(newMultiSelectKeys),
            });
            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS, newMultiSelectKeys);
            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
            (0, editTextUtils_1.teardownEditableText)(parentPort, storyboardId);
            return null; // Cannot perform regular actions on any particular node
        }
        // Special case - multiselecting but deselecting down to 1, stop the multiselect mode
        if (newMultiSelectKeys.length === 1) {
            newSelectedElement = tempoElement_1.TempoElement.fromKey(newMultiSelectKeys[0]);
        }
        const clearMultiSelectState = () => {
            // Not multi-selecting, so clear the multiselect state
            // Want to do this after setting the selected element to prevent flashing
            parentPort.postMessage({
                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MULTI_SELECTED_ELEMENT_KEYS,
                elementKeys: [],
                outerHTMLs: [],
            });
            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS, null);
        };
        // Selecting the storyboard from within
        if (newSelectedElement.isStoryboard()) {
            if (newSelectedElement.getKey() !== currentSelectedElementKey) {
                parentPort.postMessage({
                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,
                    elementKey: newSelectedElement.getKey(),
                    outerHTML: (0, changeItemFunctions_1.getFullHtmlWithElement)([newSelectedElement.getKey()]),
                });
                (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, newSelectedElement.getKey());
                (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
            }
            (0, editTextUtils_1.teardownEditableText)(parentPort, storyboardId);
            clearMultiSelectState();
            return null;
        }
        if ((0, editTextUtils_1.currentlyEditing)()) {
            const editingInfo = (0, editTextUtils_1.getEditingInfo)();
            if ((editingInfo === null || editingInfo === void 0 ? void 0 : editingInfo.key) !== currentSelectedElementKey) {
                (0, editTextUtils_1.teardownEditableText)(parentPort, storyboardId);
            }
            clearMultiSelectState();
            return null;
        }
        e.preventDefault();
        e.stopPropagation();
        if ((0, editTextUtils_1.canEditText)(newSelectedElement) &&
            newSelectedElement.getKey() === currentSelectedElementKey) {
            (0, editTextUtils_1.setupEditableText)(newSelectedElement, parentPort, storyboardId);
        }
        if (newSelectedElement.getKey() === currentSelectedElementKey) {
            clearMultiSelectState();
            return selectedNavNode;
        }
        parentPort.postMessage({
            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,
            elementKey: newSelectedElement.getKey(),
            outerHTML: (0, changeItemFunctions_1.getFullHtmlWithElement)([newSelectedElement.getKey()]),
        });
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, newSelectedElement.getKey());
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
        clearMultiSelectState();
        return selectedNavNode;
    };
    /**
     * Returns if events were passed through
     */
    const passThroughEventsIfNeeded = (e, parentPort, storyboardId) => {
        var _a, _b;
        const driveModeEnabled = !!(0, sessionStorageUtils_1.getSessionStorageItem)('driveModeEnabled', storyboardId);
        const editingTextInfo = (0, editTextUtils_1.getEditingInfo)();
        if (driveModeEnabled || editingTextInfo) {
            return true;
        }
        (_a = e === null || e === void 0 ? void 0 : e.preventDefault) === null || _a === void 0 ? void 0 : _a.call(e);
        (_b = e === null || e === void 0 ? void 0 : e.stopPropagation) === null || _b === void 0 ? void 0 : _b.call(e);
        return false;
    };
    const onClickElementContextMenu = (e, parentPort, storyboardId) => {
        const passedThrough = passThroughEventsIfNeeded(e, parentPort, storyboardId);
        if (passedThrough) {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        // Mouse down is called when a user clicks the context menu, but not mouse up, so clear the mouse down
        (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', null);
        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};
        let requestedNavNode;
        if (e.metaKey || e.ctrlKey) {
            const elementKey = (0, identifierUtils_1.getElementKeyFromNode)(e.target);
            requestedNavNode = elementKeyToNavNode[elementKey];
            // Special case -> this is the top-most node so it should trigger a context menu on the storyboard
            if (!requestedNavNode && e.target.parentNode === document.body) {
                requestedNavNode = constantsAndTypes_1.SELECT_OR_HOVER_STORYBOARD;
            }
        }
        else {
            requestedNavNode = getSelectableNavNode(e);
        }
        const currentSelectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);
        const currentMultiSelectedKeys = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS);
        if (!requestedNavNode || typeof requestedNavNode === 'string') {
            if (requestedNavNode === constantsAndTypes_1.SELECT_OR_HOVER_STORYBOARD &&
                !(currentMultiSelectedKeys === null || currentMultiSelectedKeys === void 0 ? void 0 : currentMultiSelectedKeys.length)) {
                const storyboardKey = tempoElement_1.TempoElement.forStoryboard(storyboardId).getKey();
                if (currentSelectedElementKey === storyboardKey) {
                    return;
                }
                parentPort.postMessage({
                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,
                    elementKey: storyboardKey,
                });
                (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, storyboardKey);
                (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
            }
            return;
        }
        let contextRequestedElementKey = null;
        const selectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);
        const selectedElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);
        // Don't select any children as the user might be right clicking a node they selected
        if (!requestedNavNode.tempoElement.isEqual(selectedElement) &&
            !selectedElement.isParentOf(requestedNavNode.tempoElement) &&
            !(currentMultiSelectedKeys === null || currentMultiSelectedKeys === void 0 ? void 0 : currentMultiSelectedKeys.length) // Also don't select anything new if in multiselect mode
        ) {
            contextRequestedElementKey = requestedNavNode.tempoElement.getKey();
            parentPort.postMessage({
                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,
                elementKey: contextRequestedElementKey,
                outerHTML: (0, changeItemFunctions_1.getFullHtmlWithElement)([contextRequestedElementKey]),
            });
            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, contextRequestedElementKey);
            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
        }
        const importantFields = {
            clientX: e.clientX,
            clientY: e.clientY,
        };
        parentPort.postMessage({
            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.CONTEXT_REQUESTED,
            event: importantFields,
        });
    };
    const buildAndSendNavTree = (parentPort, storyboardId, treeElementLookup, scopeLookup, storyboardComponentElement) => __awaiter(void 0, void 0, void 0, function* () {
        let treeElements = treeElementLookup;
        if (!treeElements) {
            treeElements = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.TREE_ELEMENT_LOOKUP) || {};
        }
        let scopes = scopeLookup;
        if (!scopes) {
            scopes = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SCOPE_LOOKUP) || {};
        }
        let storyboardComponent = storyboardComponentElement;
        if (storyboardComponentElement === 'EXPLICIT_NONE') {
            storyboardComponent = null;
        }
        else if (!storyboardComponent) {
            storyboardComponent = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.STORYBOARD_COMPONENT) || {};
        }
        const knownComponentNames = new Set();
        const knownComponentInstanceNames = new Set();
        if (treeElements) {
            Object.values(treeElements).forEach((treeElement) => {
                if (treeElement.type === 'component' ||
                    treeElement.type === 'storybook-component') {
                    knownComponentNames.add(treeElement.componentName);
                }
                if (treeElement.type === 'component-instance') {
                    knownComponentInstanceNames.add(treeElement.componentName);
                }
            });
        }
        const elementKeyToLookupList = {};
        const elementKeyToNavNode = {};
        const builtNavTree = yield new Promise((resolve, reject) => {
            (0, navTreeUtils_1.buildNavForNodeNonBlocking)({
                storyboardId,
                parent: undefined,
                node: (0, jquery_1.default)('body').get(0),
                uniquePathBase: '',
                uniquePathAddon: 'root',
                scopeLookup: scopes,
                treeElements,
                knownComponentNames,
                knownComponentInstanceNames,
                elementKeyToLookupList,
                elementKeyToNavNode,
                domUniquePath: '0',
            }, (result) => {
                resolve(result);
            });
        });
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_LOOKUP_LIST, elementKeyToLookupList);
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.CURRENT_NAV_TREE, builtNavTree);
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE, elementKeyToNavNode);
        parentPort.postMessage({
            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.NAV_TREE,
            navTree: builtNavTree,
            outerHtml: document.documentElement.outerHTML,
        });
        // Run callbacks
        (0, navTreeUtils_1.runNavTreeBuiltCallbacks)();
    });
    const onFlushStart = () => {
        // Find all instant update styling classes to delete
        const classesToDelete = [];
        (0, jquery_1.default)(`*[class*=${identifierUtils_1.TEMPO_INSTANT_UPDATE_STYLING_PREFIX}]`).each((i, element) => {
            const classes = (element.getAttribute('class') || '').split(' ');
            classes.forEach((className) => {
                if (className.startsWith(identifierUtils_1.TEMPO_INSTANT_UPDATE_STYLING_PREFIX)) {
                    classesToDelete.push(className);
                }
            });
        });
        (0, jquery_1.default)(`*[${identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH}=true]`).attr(identifierUtils_1.TEMPO_QUEUE_DELETE_AFTER_HOT_RELOAD, 'true');
        // Clear the add class instant update queue as those items will be applied in the hot reload
        (0, sessionStorageUtils_1.setMemoryStorageItem)(changeItemFunctions_1.ADD_CLASS_INSTANT_UPDATE_QUEUE, []);
        (0, sessionStorageUtils_1.setMemoryStorageItem)('POST_HOT_RELOAD_CLEAR', {
            classesToDelete,
        });
    };
    const clearInstantUpdatesAndSendNavTree = (parentPort, storyboardId) => __awaiter(void 0, void 0, void 0, function* () {
        globalUIUpdateRunner(() => {
            (0, sessionStorageUtils_1.setMemoryStorageItem)(LAST_NAV_TREE_REFRESH_TIME, new Date());
            const { classesToDelete } = (0, sessionStorageUtils_1.getMemoryStorageItem)('POST_HOT_RELOAD_CLEAR') || {};
            // Delete all instant update changed elements
            (0, jquery_1.default)(`*[${identifierUtils_1.TEMPO_QUEUE_DELETE_AFTER_HOT_RELOAD}=true]`).remove();
            // Clear the added display nones
            (0, jquery_1.default)(`.${identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS}`).removeClass(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);
            (0, jquery_1.default)(`*[${identifierUtils_1.TEMPO_INSTANT_UPDATE}=true]`).removeAttr(identifierUtils_1.TEMPO_INSTANT_UPDATE);
            (0, jquery_1.default)(`*[${identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH}=true]`).removeAttr(identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH);
            (0, jquery_1.default)(`.${changeItemFunctions_1.TEMPORARY_STYLING_CLASS_NAME}`).removeClass(changeItemFunctions_1.TEMPORARY_STYLING_CLASS_NAME);
            // Any classes marked to delete before the hot reload
            classesToDelete === null || classesToDelete === void 0 ? void 0 : classesToDelete.forEach((cls) => {
                (0, jquery_1.default)(`.${cls}`).removeClass(cls);
            });
            const newAddClassQueue = (0, sessionStorageUtils_1.getMemoryStorageItem)(changeItemFunctions_1.ADD_CLASS_INSTANT_UPDATE_QUEUE) || [];
            // Any attributes that start with the styling prefix leftover mean that the class needs to be re-applied
            // these are classes that were added in instant updates while the hot reload was in progress
            newAddClassQueue.forEach((item) => {
                if (!item) {
                    return;
                }
                const { codebaseId, className } = item;
                if (codebaseId && className) {
                    (0, jquery_1.default)(`.${codebaseId}`).attr(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true');
                    (0, jquery_1.default)(`.${codebaseId}`).addClass(className);
                }
            });
        });
        // Rebuild the nav tree on DOM changed after some time has passed
        // this gives the react fiber time to be fully reconciled
        try {
            yield (0, domUtils_1.sleep)(300);
            globalUIUpdateRunner(() => __awaiter(void 0, void 0, void 0, function* () {
                yield buildAndSendNavTree(parentPort, storyboardId);
                (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
            }));
        }
        catch (e) {
            console.error('ERROR: Could not re-create nav tree on DOM change, ' + e);
        }
    });
    const onDOMChanged = ({ mutations, parentPort, storyboardId, fromNextJsLoader, }) => {
        var _a;
        // Udpate the href in the parent container
        if ((0, sessionStorageUtils_1.getMemoryStorageItem)('href') !== window.location.href) {
            parentPort.postMessage({
                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.LATEST_HREF,
                href: window.location.href,
            });
            (0, sessionStorageUtils_1.setMemoryStorageItem)('href', window.location.href);
        }
        // Check if we should refresh the nav tree
        let refreshNavTree = false;
        if (fromNextJsLoader) {
            // From the nextjs loader, refresh when the loader gets hidden (means refresh is done)
            const mutationTarget = (_a = mutations === null || mutations === void 0 ? void 0 : mutations[0]) === null || _a === void 0 ? void 0 : _a.target;
            if (mutationTarget && mutationTarget.id === 'container') {
                const currentlyHotReloading = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.HOT_RELOADING);
                if (mutationTarget.classList.contains('visible')) {
                    (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOT_RELOADING, true);
                }
                else {
                    (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOT_RELOADING, false);
                    refreshNavTree = true;
                }
            }
        }
        else {
            mutations.forEach((e) => {
                if (refreshNavTree) {
                    return;
                }
                // If the class attribute has changed on an element we have to reparse the nav tree to add the element key
                if (e.type === 'attributes' &&
                    e.attributeName === 'class' &&
                    e.target &&
                    !(0, outlineUtils_1.isNodeOutline)(e.target) &&
                    !(0, identifierUtils_1.isMovingElement)(e.target) &&
                    // And not a script
                    // Bug found on Oct 8, 2024, for some reason the script kept triggering a reload
                    !e.target.tagName.toLowerCase().includes('script')) {
                    // An element which doesn't have an element key has changed
                    if (!(0, identifierUtils_1.isElementInSvg)(e.target)) {
                        refreshNavTree = true;
                    }
                    return;
                }
                [e.addedNodes, e.removedNodes].forEach((nodeList) => {
                    if (refreshNavTree) {
                        return;
                    }
                    if (!nodeList) {
                        return;
                    }
                    nodeList.forEach((node) => {
                        if (!(0, outlineUtils_1.isNodeOutline)(node) && !(0, identifierUtils_1.isMovingElement)(node)) {
                            refreshNavTree = true;
                            return;
                        }
                    });
                });
            });
        }
        if (!refreshNavTree) {
            return;
        }
        // In these cases we don't want to trigger a nav tree refresh right away
        // since the hot reload may not have happened yet. So we set a timeout and only
        // trigger a nav tree refresh if another one hasn't happened in between
        if (fromNextJsLoader) {
            const triggerTime = new Date();
            setTimeout(() => {
                const lastRefreshTime = (0, sessionStorageUtils_1.getMemoryStorageItem)(LAST_NAV_TREE_REFRESH_TIME);
                // Don't re-clear and send if another refresh has happened in the meantime
                if (!lastRefreshTime || lastRefreshTime < triggerTime) {
                    clearInstantUpdatesAndSendNavTree(parentPort, storyboardId);
                }
            }, 1000);
            return;
        }
        clearInstantUpdatesAndSendNavTree(parentPort, storyboardId);
    };
    const onWheel = (e, parentPort, storyboardId) => {
        const passedThrough = passThroughEventsIfNeeded(e, parentPort, storyboardId);
        const isScrollShortcut = e.altKey;
        const isZoomShortcut = e.ctrlKey || e.metaKey;
        // If the user wants to scroll (either by being in drive mode, or by holding alt)
        // and they aren't trying to zoom, fallback to default behaviour.
        if (!isZoomShortcut && (passedThrough || isScrollShortcut)) {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        const importantFields = {
            deltaX: e.deltaX,
            deltaY: e.deltaY,
            wheelDelta: e.wheelDelta,
            x: e.x,
            y: e.y,
            altKey: e.altKey,
            ctrlKey: e.ctrlKey,
            shiftKey: e.shiftKey,
            metaKey: e.metaKey,
        };
        parentPort.postMessage({
            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.WHEEL_EVENT,
            event: importantFields,
        });
    };
    const activeElementMetadata = () => {
        const activeElement = document.activeElement;
        let tagName, isContentEditable, elementType;
        if (activeElement) {
            tagName = activeElement.tagName;
            if (activeElement instanceof HTMLElement) {
                isContentEditable = activeElement.isContentEditable;
            }
            if (activeElement instanceof HTMLInputElement) {
                elementType = activeElement.type;
            }
        }
        return {
            tagName: tagName,
            isContentEditable: isContentEditable,
            elementType: elementType,
        };
    };
    const onKeyDown = (e, parentPort) => {
        parentPort.postMessage({
            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.KEY_DOWN_EVENT,
            event: {
                key: e.key,
                metaKey: e.metaKey,
                shiftKey: e.shiftKey,
                ctrlKey: e.ctrlKey,
                activeElement: Object.assign({}, activeElementMetadata()),
            },
        });
    };
    const onKeyUp = (e, parentPort) => {
        parentPort.postMessage({
            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.KEY_UP_EVENT,
            event: {
                key: e.key,
                metaKey: e.metaKey,
                shiftKey: e.shiftKey,
                ctrlKey: e.ctrlKey,
                activeElement: Object.assign({}, activeElementMetadata()),
            },
        });
    };
    const onScroll = (e, parentPort, storyboardId) => {
        // Let updateOutlines handle its own throttling through the global message system
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    };
    // Need to register functions on the window for channel messaging to use them
    // @ts-ignore
    window.initProject = (parentPort, storyboardId, treeElementLookup, scopeLookup, storyboardComponentElement, options = {}, storyboardType, savedComponentFilename, originalStoryboardUrl) => {
        const passive = makePassiveEventOption();
        passive['capture'] = true;
        const body$ = (0, jquery_1.default)('body');
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.TREE_ELEMENT_LOOKUP, treeElementLookup);
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SCOPE_LOOKUP, scopeLookup);
        if (storyboardComponentElement) {
            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.STORYBOARD_COMPONENT, storyboardComponentElement);
        }
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.STORYBOARD_TYPE, storyboardType);
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SAVED_STORYBOARD_COMPONENT_FILENAME, savedComponentFilename);
        // The URL that was originally loaded for this storyboard, it may be different from href
        // if the user navigated away to a new route
        if (originalStoryboardUrl) {
            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.ORIGINAL_STORYBOARD_URL, originalStoryboardUrl);
        }
        // Clear iframe outlines
        (0, sessionStorageUtils_1.removeMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);
        (0, sessionStorageUtils_1.removeMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY);
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
        // Register event listeners
        const bodyObject = body$.get(0);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('click', (e) => {
            passThroughEventsIfNeeded(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('pointerover', (e) => {
            onPointerOver(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('pointerdown', (e) => {
            onPointerDown(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('pointerup', (e) => {
            onPointerUp(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('pointermove', (e) => {
            onPointerMove(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('pointerleave', (e) => {
            passThroughEventsIfNeeded(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('contextmenu', (e) => {
            onClickElementContextMenu(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('dblclick', (e) => {
            passThroughEventsIfNeeded(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('mouseover', (e) => {
            passThroughEventsIfNeeded(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('mouseout', (e) => {
            passThroughEventsIfNeeded(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('mousemove', (e) => {
            passThroughEventsIfNeeded(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('mousedown', (e) => {
            passThroughEventsIfNeeded(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('mouseup', (e) => {
            passThroughEventsIfNeeded(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('wheel', (e) => {
            onWheel(e, parentPort, storyboardId);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('keydown', (e) => {
            onKeyDown(e, parentPort);
        }, passive);
        bodyObject === null || bodyObject === void 0 ? void 0 : bodyObject.addEventListener('keyup', (e) => {
            onKeyUp(e, parentPort);
        }, passive);
        window.addEventListener('scroll', (e) => {
            onScroll(e, parentPort, storyboardId);
        }, passive);
        // Hack: this is used to
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement &&
                (0, sessionStorageUtils_1.getMemoryStorageItem)(IMMEDIATELY_REMOVE_POINTER_LOCK)) {
                document.exitPointerLock();
                (0, sessionStorageUtils_1.setMemoryStorageItem)(IMMEDIATELY_REMOVE_POINTER_LOCK, false);
            }
        }, false);
        const debounceExecutor = new DebounceExecutor_1.DebounceExecutor();
        const objsToObserve = [bodyObject];
        const nextBuildWatcher = document.getElementById('__next-build-watcher');
        if (nextBuildWatcher && nextBuildWatcher.shadowRoot) {
            // If this is NextJS, also listen to the shadow root of the __next-build-watcher
            // This triggeres the onDOMChanged when the hot reload symbol shows up
            objsToObserve.push(...Array.from(nextBuildWatcher.shadowRoot.children));
        }
        globalUIUpdateRunner = observeDOM(objsToObserve, (e) => {
            debounceExecutor.schedule(() => {
                onDOMChanged({
                    mutations: e,
                    parentPort,
                    storyboardId,
                });
            });
        });
        if (options.driveModeEnabled) {
            enableDriveMode(parentPort, storyboardId);
        }
        else {
            disableDriveMode(parentPort, storyboardId);
        }
        if (options.aiContextSelection) {
            (0, sessionStorageUtils_1.setMemoryStorageItem)('aiContext', true);
            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
        }
        else {
            (0, sessionStorageUtils_1.setMemoryStorageItem)('aiContext', false);
            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
        }
        // Build the Nav Tree and send it back
        try {
            globalUIUpdateRunner(() => {
                buildAndSendNavTree(parentPort, storyboardId, treeElementLookup, scopeLookup, storyboardComponentElement || 'EXPLICIT_NONE');
            });
        }
        catch (e) {
            console.log(e);
            console.error('Error building nav tree: ' + e);
        }
    };
    const enableDriveMode = (parentPort, storyboardId) => {
        // @ts-ignore
        if (!(0, sessionStorageUtils_1.getSessionStorageItem)('driveModeEnabled', storyboardId)) {
            // @ts-ignore
            (0, sessionStorageUtils_1.setSessionStorageItem)('driveModeEnabled', 'enabled', storyboardId);
            clearHoveredElements(parentPort, storyboardId);
            (0, outlineUtils_1.clearAllOutlines)();
        }
        (0, jquery_1.default)('body').css('cursor', '');
    };
    const disableDriveMode = (parentPort, storyboardId) => {
        // @ts-ignore
        if ((0, sessionStorageUtils_1.getSessionStorageItem)('driveModeEnabled', storyboardId)) {
            // @ts-ignore
            (0, sessionStorageUtils_1.removeSessionStorageItem)('driveModeEnabled', storyboardId);
            (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
            clearHoveredElements(parentPort, storyboardId);
        }
        (0, jquery_1.default)('body').attr('style', function (i, s) {
            return (s || '') + 'cursor: default !important;';
        });
    };
    // @ts-ignore
    window.enableDriveMode = (parentPort, storyboardId) => {
        enableDriveMode(parentPort, storyboardId);
    };
    // @ts-ignore
    window.disableDriveMode = (parentPort, storyboardId) => {
        disableDriveMode(parentPort, storyboardId);
    };
    // @ts-ignore
    window.setNewLookups = (parentPort, storyboardId, treeElementLookup, scopeLookup) => {
        const prevTreeElemntLookup = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.TREE_ELEMENT_LOOKUP) || {};
        const prevScopeLookup = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SCOPE_LOOKUP) || {};
        const newTreeElements = Object.assign({}, prevTreeElemntLookup);
        // Delete any tree elements that were set to nul
        Object.keys(treeElementLookup).forEach((key) => {
            if (treeElementLookup[key]) {
                newTreeElements[key] = treeElementLookup[key];
            }
            else if (newTreeElements[key]) {
                delete newTreeElements[key];
            }
        });
        const newScopes = Object.assign({}, prevScopeLookup);
        // Delete any scopes that were set to nul
        Object.keys(scopeLookup).forEach((key) => {
            if (scopeLookup[key]) {
                newScopes[key] = scopeLookup[key];
            }
            else if (newScopes[key]) {
                delete newScopes[key];
            }
        });
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.TREE_ELEMENT_LOOKUP, newTreeElements);
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SCOPE_LOOKUP, newScopes);
    };
    // @ts-ignore
    window.setHoveredElement = (parentPort, storyboardId, elementKey) => {
        const driveModeEnabled = !!(0, sessionStorageUtils_1.getSessionStorageItem)('driveModeEnabled', storyboardId);
        if (driveModeEnabled) {
            return;
        }
        const prevHoveredElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY);
        if (prevHoveredElementKey === elementKey) {
            return;
        }
        if (elementKey) {
            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY, elementKey);
        }
        else {
            (0, sessionStorageUtils_1.removeMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY);
        }
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    };
    // @ts-ignore
    window.setSelectedElement = (parentPort, storyboardId, elementKey) => {
        var _a;
        const prevSelectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);
        if (prevSelectedElementKey === elementKey) {
            return;
        }
        if (elementKey) {
            const tempoElement = tempoElement_1.TempoElement.fromKey(elementKey);
            let elementKeyToExtract = elementKey;
            if (tempoElement.isStoryboard(storyboardId)) {
                // Pass back the outerHTML of the top level node
                const topLevelNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.CURRENT_NAV_TREE);
                const topLevelElementKey = (_a = topLevelNode === null || topLevelNode === void 0 ? void 0 : topLevelNode.tempoElement) === null || _a === void 0 ? void 0 : _a.getKey();
                if (topLevelElementKey) {
                    elementKeyToExtract = topLevelElementKey;
                }
            }
            // Send back the message just to set the outerHTML only
            parentPort.postMessage({
                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,
                doNotSetElementKey: true,
                outerHTML: (0, changeItemFunctions_1.getFullHtmlWithElement)([elementKeyToExtract]),
            });
            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, elementKey);
        }
        else {
            parentPort.postMessage({
                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,
                doNotSetElementKey: true,
                outerHTML: null,
            });
            (0, sessionStorageUtils_1.removeMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);
        }
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    };
    // @ts-ignore
    window.setMultiselectedElementKeys = (parentPort, storyboardId, elementKeys) => {
        const prevMultiSelectedElementKeys = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS);
        const prevSet = new Set(prevMultiSelectedElementKeys || []);
        const newSet = new Set(elementKeys || []);
        const setsEqual = prevSet.size === newSet.size &&
            [...prevSet].every((value) => newSet.has(value));
        if (setsEqual) {
            return;
        }
        if (elementKeys) {
            (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS, elementKeys);
            parentPort.postMessage({
                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MULTI_SELECTED_ELEMENT_KEYS,
                doNotSetElementKeys: true,
                outerHTMLs: (0, changeItemFunctions_1.getFullHtmlWithElement)(elementKeys),
            });
        }
        else {
            (0, sessionStorageUtils_1.removeMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS);
            parentPort.postMessage({
                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MULTI_SELECTED_ELEMENT_KEYS,
                doNotSetElementKeys: true,
                outerHTMLs: [],
            });
        }
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    };
    // @ts-ignore
    window.processRulesForSelectedElement = (parentPort, storyboardId, cssElementLookup, selectedElementKey) => {
        (0, cssFunctions_1.processRulesForSelectedElement)(parentPort, cssElementLookup, selectedElementKey);
    };
    // @ts-ignore
    window.setModifiersForSelectedElement = (parentPort, storyboardId, modifiers, selectedElementKey) => {
        (0, cssFunctions_1.setModifiersForSelectedElement)(parentPort, modifiers, selectedElementKey);
    };
    // @ts-ignore
    window.getCssEvals = (parentPort, storyboardId, selectedElementKey) => {
        (0, cssFunctions_1.getCssEvals)(parentPort, selectedElementKey);
    };
    // @ts-ignore
    window.ruleMatchesElement = (parentPort, storyboardId, messageId, rule, selectedElementKey) => {
        (0, cssFunctions_1.ruleMatchesElement)(parentPort, messageId, rule, selectedElementKey);
    };
    // @ts-ignore
    window.getElementClassList = (parentPort, storyboardId, selectedElementKey) => {
        (0, cssFunctions_1.getElementClassList)(parentPort, selectedElementKey);
    };
    // @ts-ignore
    window.applyChangeItemToDocument = (parentPort, storyboardId, changeItem) => __awaiter(void 0, void 0, void 0, function* () {
        const { sendNewNavTree } = (0, changeItemFunctions_1.applyChangeItemToDocument)(parentPort, storyboardId, changeItem);
        // Update the nav tree & outlines
        if (sendNewNavTree) {
            yield buildAndSendNavTree(parentPort, storyboardId);
        }
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    });
    // @ts-ignore
    window.updateCodebaseIds = (parentPort, storyboardId, prevIdToNewIdMap, newTreeElementLookup, newScopeLookup) => __awaiter(void 0, void 0, void 0, function* () {
        const sendNewNavTree = (0, changeItemFunctions_1.updateCodebaseIds)(parentPort, prevIdToNewIdMap, true);
        if (sendNewNavTree) {
            yield buildAndSendNavTree(parentPort, storyboardId, newTreeElementLookup, newScopeLookup);
        }
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    });
    // @ts-ignore
    window.dispatchEvent = (parentPort, storyboardId, eventName, eventDetails) => {
        const event = new CustomEvent(eventName, Object.assign({}, eventDetails));
        document.dispatchEvent(event);
    };
    // @ts-ignore
    window.updateOutlines = (parentPort, storyboardId) => {
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    };
    // @ts-ignore
    window.goBack = (parentPort, storyboardId) => {
        if (document.referrer !== '') {
            window.history.back();
        }
    };
    // @ts-ignore
    window.goForward = (parentPort, storyboardId) => {
        window.history.forward();
    };
    // @ts-ignore
    window.refresh = (parentPort, storyboardId) => {
        window.location.reload();
    };
    // @ts-ignore
    window.syntheticMouseOver = (parentPort, storyboardId, coords, dontHoverInsideSelected, selectBottomMostElement) => {
        const target = document.elementFromPoint(coords.x, coords.y);
        // If this is true we don't want to trigger a hover event inside a selected element, instead just set hovering on the selected element
        if (dontHoverInsideSelected) {
            const selectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);
            const selectedElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);
            if (!selectedElement.isEmpty()) {
                const selectedDomElement = (0, identifierUtils_1.getNodeForElementKey)(selectedElementKey);
                if (selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.contains(target)) {
                    onPointerOver({ target: selectedDomElement }, parentPort, storyboardId);
                    return;
                }
            }
        }
        onPointerOver({ target }, parentPort, storyboardId, selectBottomMostElement);
    };
    // @ts-ignore
    window.syntheticMouseMove = (parentPort, storyboardId, syntheticEvent) => {
        const eventWithClient = Object.assign(Object.assign({}, syntheticEvent), { pageX: syntheticEvent.clientX +
                (document.documentElement.scrollLeft || document.body.scrollLeft), pageY: syntheticEvent.clientY +
                (document.documentElement.scrollTop || document.body.scrollTop) });
        onPointerMove(eventWithClient, parentPort, storyboardId);
    };
    // @ts-ignore
    window.syntheticMouseUp = (parentPort, storyboardId, syntheticEvent) => {
        onPointerUp(syntheticEvent, parentPort, storyboardId);
    };
    // @ts-ignore
    window.clearHoveredOutlines = (parentPort, storyboardId) => {
        if ((0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.HOVERED_ELEMENT_KEY)) {
            clearHoveredElements(parentPort, storyboardId);
        }
    };
    // @ts-ignore
    window.setZoomPerc = (parentPort, storyboardId, zoomPerc) => {
        (0, sessionStorageUtils_1.setMemoryStorageItem)('zoomPerc', zoomPerc.toString());
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    };
    // @ts-ignore
    window.setAiContext = (parentPort, storyboardId, aiContext) => {
        (0, sessionStorageUtils_1.setMemoryStorageItem)('aiContext', !!aiContext);
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    };
    // @ts-ignore
    window.tempMoveElement = (parentPort, storyboardId, nodeToMoveElementKey, newIndex) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};
        const navNodeToMove = elementKeyToNavNode[nodeToMoveElementKey];
        if (!navNodeToMove) {
            return;
        }
        const nodeToMoveElement = tempoElement_1.TempoElement.fromKey(nodeToMoveElementKey);
        const domElementsToMove = [];
        // In components, there may be multiple elements that need to be moved, the eleemntKeyToLookupList
        // are all the real DOM elements in a component
        // For non-components, the eleemntKeyToLookupList points to a list of itself
        const elementKeyToLookupList = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_LOOKUP_LIST) || {};
        const lookupList = elementKeyToLookupList[navNodeToMove.tempoElement.getKey()] || [];
        lookupList.forEach((lookupElementKey) => {
            domElementsToMove.push((0, identifierUtils_1.getNodeForElementKey)(lookupElementKey));
        });
        const parentDomElement = (_a = domElementsToMove[0]) === null || _a === void 0 ? void 0 : _a.parentElement;
        const parentNavNode = navNodeToMove.parent;
        if (parentDomElement && parentNavNode) {
            const currentIndex = (_b = parentNavNode === null || parentNavNode === void 0 ? void 0 : parentNavNode.children) === null || _b === void 0 ? void 0 : _b.indexOf(navNodeToMove);
            const numChildren = (_c = parentNavNode === null || parentNavNode === void 0 ? void 0 : parentNavNode.children) === null || _c === void 0 ? void 0 : _c.length;
            if (currentIndex !== newIndex) {
                Array.from(parentDomElement.children).forEach((child) => {
                    (0, jquery_1.default)(child).attr(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true');
                });
                (0, jquery_1.default)(parentDomElement).attr(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true');
                if (newIndex === numChildren - 1) {
                    domElementsToMove.forEach((element) => {
                        element.parentElement.appendChild(element);
                    });
                }
                else {
                    // If the current index is before the new index then we need to adjust by 1 to account for the shift in indices
                    const beforeNode = currentIndex > newIndex
                        ? parentNavNode === null || parentNavNode === void 0 ? void 0 : parentNavNode.children[newIndex]
                        : parentNavNode === null || parentNavNode === void 0 ? void 0 : parentNavNode.children[newIndex + 1];
                    const lookupListForBefore = elementKeyToLookupList[(_d = beforeNode === null || beforeNode === void 0 ? void 0 : beforeNode.tempoElement) === null || _d === void 0 ? void 0 : _d.getKey()] || [];
                    if (!lookupListForBefore.length) {
                        console.log('Cannot find element to insert before in lookup list');
                        return;
                    }
                    const beforeDomElement = (0, identifierUtils_1.getNodeForElementKey)(lookupListForBefore[0]);
                    if (!beforeDomElement) {
                        console.log('Cannot find element to insert before');
                        return;
                    }
                    domElementsToMove.forEach((element) => {
                        element.parentElement.insertBefore(element, beforeDomElement);
                    });
                }
                // Update the selected element key to the new expected one (note if moving there is no hovered element key)
                // This also assumes the nodeToMoveElementKey is the selected element key
                const elementToMoveSegments = nodeToMoveElement.uniquePath.split('-');
                const newSelectedUniquePath = elementToMoveSegments
                    .slice(0, elementToMoveSegments.length - 1)
                    .join('-') + `-${newIndex}`;
                const newSelectedElementKey = new tempoElement_1.TempoElement(nodeToMoveElement.codebaseId, nodeToMoveElement.storyboardId, newSelectedUniquePath).getKey();
                // Update the nav tree which also sets the element key on all the elements, need to do this before
                // updating the selected element key
                yield buildAndSendNavTree(parentPort, storyboardId);
                // Codebase ID doesn't change
                parentPort.postMessage({
                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,
                    elementKey: newSelectedElementKey,
                    outerHTML: (0, changeItemFunctions_1.getFullHtmlWithElement)([newSelectedElementKey]),
                });
                (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, newSelectedElementKey);
                (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
            }
        }
    });
    // @ts-ignore
    window.tempAddDiv = (parentPort, storyboardId, parentCodebaseId, indexInParent, width, height) => __awaiter(void 0, void 0, void 0, function* () {
        const element = (0, jquery_1.default)(`.${identifierUtils_1.TEMPO_INSTANT_DIV_DRAW_CLASS}`);
        if (element.length) {
            element.css('width', width);
            element.css('height', height);
        }
        else {
            let parent = (0, jquery_1.default)(`.${parentCodebaseId}`);
            if (!parent.length) {
                parent = (0, jquery_1.default)('body');
            }
            parent.each((index, item) => {
                const newElement = (0, jquery_1.default)(`<div class="${identifierUtils_1.TEMPO_INSTANT_DIV_DRAW_CLASS}" ${identifierUtils_1.TEMPO_DELETE_AFTER_INSTANT_UPDATE}="true" ${identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH}="true" ${identifierUtils_1.TEMPO_INSTANT_UPDATE}="true"></div>`);
                const childAtIndex = (0, jquery_1.default)(item).children().eq(indexInParent);
                if (childAtIndex === null || childAtIndex === void 0 ? void 0 : childAtIndex.length) {
                    childAtIndex.before(newElement);
                }
                else {
                    (0, jquery_1.default)(item).append(newElement);
                }
            });
            // Update the nav tree
            yield buildAndSendNavTree(parentPort, storyboardId);
        }
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    });
    // @ts-ignore
    window.tempMoveToNewParent = (parentPort, storyboardId, indicatorWidth, indicatorHeight, newPositionX, newPositionY, parentElementKey, clear) => {
        (0, jquery_1.default)(`.${identifierUtils_1.TEMPO_MOVE_BETWEEN_PARENTS_OUTLINE}`).remove();
        if (clear) {
            return;
        }
        const newElement = document.createElement('div');
        newElement.classList.add(identifierUtils_1.TEMPO_MOVE_BETWEEN_PARENTS_OUTLINE);
        newElement.setAttribute(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true'); // Add so it doesn't trigger new nav tree building
        newElement.style.width = indicatorWidth + 'px';
        newElement.style.height = indicatorHeight + 'px';
        newElement.style.left = newPositionX + 'px';
        newElement.style.top = newPositionY + 'px';
        newElement.style.position = 'fixed';
        newElement.style.pointerEvents = 'none';
        newElement.style.zIndex = '2000000004';
        newElement.style.boxSizing = 'border-box';
        newElement.style.cursor = 'default !important';
        newElement.style.backgroundColor = outlineUtils_1.PRIMARY_OUTLINE_COLOUR;
        const body = document.getElementsByTagName('body')[0];
        body.appendChild(newElement);
        const parentDomElement = (0, identifierUtils_1.getNodeForElementKey)(parentElementKey);
        if (parentDomElement) {
            const boundingRect = parentDomElement.getBoundingClientRect();
            const parentOutline = (0, outlineUtils_1.getOutlineElement)(parentPort, outlineUtils_1.OutlineType.PRIMARY, boundingRect.left, boundingRect.top, boundingRect.width, boundingRect.height);
            parentOutline.classList.remove(identifierUtils_1.OUTLINE_CLASS);
            parentOutline.classList.add(identifierUtils_1.TEMPO_MOVE_BETWEEN_PARENTS_OUTLINE);
            parentOutline.setAttribute(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true'); // Add so it doesn't trigger new nav tree building
            body.appendChild(parentOutline);
        }
    };
    // @ts-ignore
    window.checkIfHydrationError = (parentPort, storyboardId) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        let errorDescr, errorLabel, errorBody, hasError;
        if (window.location.href.includes('framework=VITE')) {
            // @ts-ignore
            const errorPortal = (_a = document.getElementsByTagName('vite-error-overlay')[0]) === null || _a === void 0 ? void 0 : _a.shadowRoot;
            errorDescr = 'A Vite Error Occurred';
            errorLabel =
                (_d = (_c = (_b = errorPortal === null || errorPortal === void 0 ? void 0 : errorPortal.querySelectorAll) === null || _b === void 0 ? void 0 : _b.call(errorPortal, '.file-link')) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.innerHTML;
            errorBody = (_g = (_f = (_e = errorPortal === null || errorPortal === void 0 ? void 0 : errorPortal.querySelectorAll) === null || _e === void 0 ? void 0 : _e.call(errorPortal, '.message')) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g.innerHTML;
            hasError = Boolean(errorLabel || errorBody);
        }
        else {
            // @ts-ignore
            const errorPortal = (_h = document.getElementsByTagName('nextjs-portal')[0]) === null || _h === void 0 ? void 0 : _h.shadowRoot;
            errorDescr = (_k = (_j = errorPortal === null || errorPortal === void 0 ? void 0 : errorPortal.getElementById) === null || _j === void 0 ? void 0 : _j.call(errorPortal, 'nextjs__container_errors_desc')) === null || _k === void 0 ? void 0 : _k.innerHTML;
            errorLabel = (_m = (_l = errorPortal === null || errorPortal === void 0 ? void 0 : errorPortal.getElementById) === null || _l === void 0 ? void 0 : _l.call(errorPortal, 'nextjs__container_errors_label')) === null || _m === void 0 ? void 0 : _m.innerHTML;
            errorBody = (_q = (_p = (_o = errorPortal === null || errorPortal === void 0 ? void 0 : errorPortal.querySelectorAll) === null || _o === void 0 ? void 0 : _o.call(errorPortal, '.nextjs-container-errors-body')) === null || _p === void 0 ? void 0 : _p[0]) === null || _q === void 0 ? void 0 : _q.innerHTML;
            hasError = Boolean(errorDescr);
        }
        // Check if the contents of the hydration container contain the text "Hydration failed"
        if (hasError) {
            if (errorDescr === null || errorDescr === void 0 ? void 0 : errorDescr.includes('Hydration failed')) {
                parentPort.postMessage({
                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.LATEST_HYDRATION_ERROR_STATUS,
                    status: constantsAndTypes_1.STORYBOARD_HYDRATION_STATUS.ERROR,
                    errorDescr,
                    errorLabel,
                    errorBody,
                });
            }
            else {
                parentPort.postMessage({
                    id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.LATEST_HYDRATION_ERROR_STATUS,
                    status: constantsAndTypes_1.STORYBOARD_HYDRATION_STATUS.OTHER_ERROR,
                    errorDescr,
                    errorLabel,
                    errorBody,
                });
            }
        }
        else {
            parentPort.postMessage({
                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.LATEST_HYDRATION_ERROR_STATUS,
                status: constantsAndTypes_1.STORYBOARD_HYDRATION_STATUS.NO_ERROR,
            });
        }
    };
    // @ts-ignore
    window.triggerDragStart = (parentPort, storyboardId) => {
        const selectedElementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY);
        const elementKeyToNavNode = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.ELEMENT_KEY_TO_NAV_NODE) || {};
        // Something has to be selected to trigger a drag start
        if (!selectedElementKey) {
            return;
        }
        const draggedNavNode = elementKeyToNavNode[selectedElementKey];
        const parentDomElement = getParentDomElementForNavNode(draggedNavNode);
        const mouseDragContext = {
            // Start off screen, this will get updated by onMouseMove
            pageX: -10000,
            pageY: -10000,
            // The difference between where the user clicked and the center of the element
            offsetX: 0,
            offsetY: 0,
            dragging: true,
            selectedParentDisplay: (0, cssFunctions_1.cssEval)(parentDomElement, 'display'),
            selectedParentFlexDirection: (0, cssFunctions_1.cssEval)(parentDomElement, 'flex-direction'),
        };
        (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', mouseDragContext);
        // Trigger the drag start event
        parentPort.postMessage({
            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.DRAG_START_EVENT,
            event: mouseDragContext,
            outerHTML: (0, changeItemFunctions_1.getFullHtmlWithElement)([selectedElementKey]),
        });
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    };
    // @ts-ignore
    window.triggerDragCancel = (parentPort, storyboardId) => {
        (0, sessionStorageUtils_1.setMemoryStorageItem)('mouseDragContext', null);
        parentPort.postMessage({
            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.DRAG_CANCEL_EVENT,
            event: {},
        });
        (0, outlineUtils_1.updateOutlines)(parentPort, storyboardId);
    };
    // @ts-ignore
    window.setIsFlushing = (parentPort, storyboardId, isFlushing) => {
        const wasFlushing = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.IS_FLUSHING);
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.IS_FLUSHING, isFlushing);
        if (isFlushing && !wasFlushing) {
            onFlushStart();
        }
    };
    // @ts-ignore
    window.captureComponentPreview = (parentPort, storyboardId, componentKey, codebaseId) => __awaiter(void 0, void 0, void 0, function* () {
        // Extract canvas ID from the current URL path
        let canvasId;
        try {
            const urlPath = window.location.pathname;
            const canvasMatch = urlPath.match(/\/canvas\/([^\/]+)/);
            canvasId = canvasMatch ? canvasMatch[1] : undefined;
        }
        catch (error) {
            console.warn('Could not extract canvas ID from URL:', error);
        }
        try {
            // Wait for the page to be fully loaded
            yield new Promise((resolve) => {
                if (document.readyState === 'complete') {
                    resolve(void 0);
                }
                else {
                    const onLoad = () => {
                        window.removeEventListener('load', onLoad);
                        resolve(void 0);
                    };
                    window.addEventListener('load', onLoad);
                    // Fallback timeout in case load event doesn't fire
                    setTimeout(() => {
                        window.removeEventListener('load', onLoad);
                        resolve(void 0);
                    }, 2000);
                }
            });
            // Find the component element to capture
            let targetElement = null;
            if (componentKey) {
                targetElement = (0, identifierUtils_1.getNodeForElementKey)(componentKey);
            }
            else if (codebaseId) {
                // Fallback to codebase ID selector
                targetElement = document.querySelector(`.${codebaseId}`);
            }
            if (!targetElement) {
                // Fallback to finding the first element with tempoelementid attribute
                targetElement = document.querySelector('[tempoelementid]');
                if (!targetElement) {
                    // Final fallback to main content area
                    targetElement =
                        document.querySelector('[data-tempo-root]') || document.body;
                }
            }
            // Get the actual dimensions of the target element
            const rect = targetElement.getBoundingClientRect();
            const elementWidth = Math.max(rect.width, 80); // Minimum width of 80px
            const elementHeight = Math.max(rect.height, 60); // Minimum height of 60px
            const maxWidth = 800;
            const maxHeight = 600;
            const captureWidth = Math.min(elementWidth, maxWidth);
            const captureHeight = Math.min(elementHeight, maxHeight);
            // Configure capture options for better performance and quality
            const options = {
                quality: 0.8,
                pixelRatio: 2,
                backgroundColor: '#ffffff',
                width: captureWidth,
                height: captureHeight,
                style: {
                    transform: 'scale(1)',
                    transformOrigin: 'top left',
                },
                // Optimized filter to exclude problematic elements
                filter: (node) => {
                    // Skip script tags, styles, and invisible elements
                    if (node.tagName === 'SCRIPT' || node.tagName === 'STYLE') {
                        return false;
                    }
                    // Filter out outline elements and other UI overlays
                    if (node.classList) {
                        return (!node.classList.contains('tempo-outline') &&
                            !node.classList.contains('tempo-ui-overlay') &&
                            !node.classList.contains(identifierUtils_1.TEMPO_INSTANT_DIV_DRAW_CLASS));
                    }
                    return true;
                },
                // Skip external resources to avoid network delays
                skipFonts: true,
                fetchRequestInit: {
                    mode: 'no-cors',
                },
            };
            const dataUrl = yield (0, html_to_image_1.toJpeg)(targetElement, options);
            // Send the captured image back to the parent
            parentPort.postMessage({
                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.COMPONENT_PREVIEW_CAPTURED,
                imageDataUrl: dataUrl,
                componentKey,
                codebaseId,
                storyboardId,
                canvasId, // Include canvas ID for deterministic storage
            });
        }
        catch (error) {
            console.error(' [CAPTURE] Failed to capture component preview:', error);
            // Send error message back
            parentPort.postMessage({
                id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.COMPONENT_PREVIEW_ERROR,
                // @ts-ignore
                error: error === null || error === void 0 ? void 0 : error.message,
                componentKey,
                codebaseId,
                storyboardId,
                canvasId, // Include canvas ID for error tracking
            });
        }
    });
};
exports.initChannelMessagingFunctions = initChannelMessagingFunctions;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhbm5lbE1lc3NhZ2luZ0Z1bmN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jaGFubmVsTWVzc2FnaW5nL2NoYW5uZWxNZXNzYWdpbmdGdW5jdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdURBaUIyQjtBQUMzQiwrREFxQitCO0FBQy9CLGlEQU13QjtBQUV4QixhQUFhO0FBQ2Isb0RBQXVCO0FBQ3ZCLG9EQUF1QjtBQUN2QixpREFPd0I7QUFDeEIsaURBT3dCO0FBQ3hCLDJEQUk2QjtBQUM3QiwrREFPK0I7QUFDL0IsaURBQThDO0FBRTlDLG1EQU15QjtBQUN6QixnRUFBNkQ7QUFDN0QseUNBQTBEO0FBQzFELE1BQU0sMEJBQTBCLEdBQUcsRUFBRSxDQUFDO0FBRXRDLE1BQU0sK0JBQStCLEdBQUcsaUNBQWlDLENBQUM7QUFDMUUsTUFBTSwwQkFBMEIsR0FBRyw0QkFBNEIsQ0FBQztBQUNoRSxNQUFNLDZCQUE2QixHQUFHLCtCQUErQixDQUFDO0FBRXRFLGlEQUF1QztBQUV2QyxNQUFNLG1CQUFtQixHQUFHLEVBQUUsQ0FBQztBQUUvQix5REFBeUQ7QUFFbEQsTUFBTSw2QkFBNkIsR0FBRyxHQUFHLEVBQUU7SUFDaEQsbUNBQW1DO0lBQ25DLGFBQWE7SUFDYixJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTtRQUMzQixPQUFPO0tBQ1I7SUFDRCxhQUFhO0lBQ2IsTUFBTSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQztJQUUvQixJQUFBLG9FQUE4QyxHQUFFLENBQUM7SUFFakQsOEdBQThHO0lBQzlHLElBQUksb0JBQW9CLEdBQUcsZ0NBQXFCLENBQUM7SUFFakQsMkRBQTJEO0lBQzNELE1BQU0sNkJBQTZCLEdBQUcsSUFBSSxHQUFHLEVBQW9CLENBQUM7SUFFbEUsTUFBTSxvQkFBb0IsR0FBRyxDQUFDLFVBQWUsRUFBRSxPQUFZLEVBQUUsRUFBRTtRQUM3RCxNQUFN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QUU7WUFDVCx5QkFBeUIsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3pELENBQUMsRUFDRCxPQUFPLENBQ1IsQ0FBQztRQUVGLFVBQVUsYUFBVixVQUFVLHVCQUFWLFVBQVUsQ0FBRSxnQkFBZ0IsQ0FDMUIsV0FBVyxFQUNYLENBQUMsQ0FBTSxFQUFFLEVBQUU7WUFDVCx5QkFBeUIsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3pELENBQUMsRUFDRCxPQUFPLENBQ1IsQ0FBQztRQUNGLFVBQVUsYUFBVixVQUFVLHVCQUFWLFVBQVUsQ0FBRSxnQkFBZ0IsQ0FDMUIsVUFBVSxFQUNWLENBQUMsQ0FBTSxFQUFFLEVBQUU7WUFDVCx5QkFBeUIsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3pELENBQUMsRUFDRCxPQUFPLENBQ1IsQ0FBQztRQUNGLFVBQVUsYUFBVixVQUFVLHVCQUFWLFVBQVUsQ0FBRSxnQkFBZ0IsQ0FDMUIsV0FBVyxFQUNYLENBQUMsQ0FBTSxFQUFFLEVBQUU7WUFDVCx5QkFBeUIsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3pELENBQUMsRUFDRCxPQUFPLENBQ1IsQ0FBQztRQUNGLFVBQVUsYUFBVixVQUFVLHVCQUFWLFVBQVUsQ0FBRSxnQkFBZ0IsQ0FDMUIsV0FBVyxFQUNYLENBQUMsQ0FBTSxFQUFFLEVBQUU7WUFDVCx5QkFBeUIsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3pELENBQUMsRUFDRCxPQUFPLENBQ1IsQ0FBQztRQUNGLFVBQVUsYUFBVixVQUFVLHVCQUFWLFVBQVUsQ0FBRSxnQkFBZ0IsQ0FDMUIsU0FBUyxFQUNULENBQUMsQ0FBTSxFQUFFLEVBQUU7WUFDVCx5QkFBeUIsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3pELENBQUMsRUFDRCxPQUFPLENBQ1IsQ0FBQztRQUNG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SDtvQkFDRCxPQUFPLElBQUksQ0FBQztnQkFDZCxDQUFDO2dCQUNELGtEQUFrRDtnQkFDbEQsU0FBUyxFQUFFLElBQUk7Z0JBQ2YsZ0JBQWdCLEVBQUU7b0JBQ2hCLElBQUksRUFBRSxTQUF3QjtpQkFDL0I7YUFDRixDQUFDO1lBRUYsTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFBLHNCQUFNLEVBQUMsYUFBNEIsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUVwRSw2Q0FBNkM7WUFDN0MsVUFBVSxDQUFDLFdBQVcsQ0FBQztnQkFDckIsRUFBRSxFQUFFLDRDQUF3QixDQUFDLDBCQUEwQjtnQkFDdkQsWUFBWSxFQUFFLE9BQU87Z0JBQ3JCLFlBQVk7Z0JBQ1osVUFBVTtnQkFDVixZQUFZO2dCQUNaLFFBQVEsRUFBRSw4Q0FBOEM7YUFDekQsQ0FBQyxDQUFDO1NBQ0o7UUFBQyxPQUFPLEtBQUssRUFBRTtZQUNkLE9BQU8sQ0FBQyxLQUFLLENBQUMsa0RBQWtELEVBQUUsS0FBSyxDQUFDLENBQUM7WUFFekUsMEJBQTBCO1lBQzFCLFVBQVUsQ0FBQyxXQUFXLENBQUM7Z0JBQ3JCLEVBQUUsRUFBRSw0Q0FBd0IsQ0FBQyx1QkFBdUI7Z0JBQ3BELGFBQWE7Z0JBQ2IsS0FBSyxFQUFFLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxPQUFPO2dCQUNyQixZQUFZO2dCQUNaLFVBQVU7Z0JBQ1YsWUFBWTtnQkFDWixRQUFRLEVBQUUsdUNBQXVDO2FBQ2xELENBQUMsQ0FBQztTQUNKO0lBQ0gsQ0FBQyxDQUFBLENBQUM7QUFDSixDQUFDLENBQUM7QUFuMkVXLFFBQUEsNkJBQTZCLGlDQW0yRXhDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgaXNNb3ZpbmdFbGVtZW50LFxuICBURU1QT19ERUxFVEVfQUZURVJfUkVGUkVTSCxcbiAgVEVNUE9fSU5TVEFOVF9VUERBVEUsXG4gIFRFTVBPX0lOU1RBTlRfRElWX0RSQVdfQ0xBU1MsXG4gIFRFTVBPX01PVkVfQkVUV0VFTl9QQVJFTlRTX09VVExJTkUsXG4gIE9VVExJTkVfQ0xBU1MsXG4gIFRFTVBPX0RJU1BMQVlfTk9ORV9VTlRJTF9SRUZSRVNIX0NMQVNTLFxuICBnZXRFbGVtZW50S2V5RnJvbU5vZGUsXG4gIFRFTVBPX0RPX05PVF9TSE9XX0lOX05BVl9VTlRJTF9SRUZSRVNILFxuICBURU1QT19JTlNUQU5UX1VQREFURV9TVFlMSU5HX1BSRUZJWCxcbiAgRURJVF9URVhUX0JVVFRPTixcbiAgaGFzQ2xhc3MsXG4gIFRFTVBPX1FVRVVFX0RFTEVURV9BRlRFUl9IT1RfUkVMT0FELFxuICBURU1QT19ERUxFVEVfQUZURVJfSU5TVEFOVF9VUERBVEUsXG4gIGlzRWxlbWVudEluU3ZnLFxuICBnZXROb2RlRm9yRWxlbWVudEtleSxcbn0gZnJvbSAnLi9pZGVudGlmaWVyVXRpbHMnO1xuaW1wb3J0IHtcbiAgQ1VSUkVOVF9OQVZfVFJFRSxcbiAgSE9WRVJFRF9FTEVNRU5UX0tFWSxcbiAgU0FWRURfU1RPUllCT0FSRF9DT01QT05FTlRfRklMRU5BTUUsXG4gIFNDT1BFX0xPT0tVUCxcbiAgU0VMRUNURURfRUxFTUVOVF9LRVksXG4gIFNUT1JZQk9BUkRfQ09NUE9ORU5ULFxuICBTVE9SWUJPQVJEX1RZUEUsXG4gIFRSRUVfRUxFTUVOVF9MT09LVVAsXG4gIEVMRU1FTlRfS0VZX1RPX0xPT0tVUF9MSVNULFxuICBFTEVNRU5UX0tFWV9UT19OQVZfTk9ERSxcbiAgZ2V0TWVtb3J5U3RvcmFnZUl0ZW0sXG4gIGdldFNlc3Npb25TdG9yYWdlSXRlbSxcbiAgcmVtb3ZlTWVtb3J5U3RvcmFnZUl0ZW0sXG4gIHJlbW92ZVNlc3Npb25TdG9yYWdlSXRlbSxcbiAgc2V0TWVtb3J5U3RvcmFnZUl0ZW0sXG4gIHNldFNlc3Npb25TdG9yYWdlSXRlbSxcbiAgTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTLFxuICBIT1RfUkVMT0FESU5HLFxuICBJU19GTFVTSElORyxcbiAgT1JJR0lOQUxfU1RPUllCT0FSRF9VUkwsXG59IGZyb20gJy4vc2Vzc2lvblN0b3JhZ2VVdGlscyc7XG5pbXBvcnQge1xuICBOYXZUcmVlTm9kZSxcbiAgU0tJUF9ST09UX0NPREVCQVNFX0lELFxuICBidWlsZE5hdkZvck5vZGVOb25CbG9ja2luZyxcbiAgcnVuTmF2VHJlZUJ1aWx0Q2FsbGJhY2tzLFxuICBhZGROYXZUcmVlQnVpbHRDYWxsYmFjayxcbn0gZnJvbSAnLi9uYXZUcmVlVXRpbHMnO1xuXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7XG4gIE91dGxpbmVUeXBlLFxuICBQUklNQVJZX09VVExJTkVfQ09MT1VSLFxuICBjbGVhckFsbE91dGxpbmVzLFxuICBnZXRPdXRsaW5lRWxlbWVudCxcbiAgaXNOb2RlT3V0bGluZSxcbiAgdXBkYXRlT3V0bGluZXMsXG59IGZyb20gJy4vb3V0bGluZVV0aWxzJztcbmltcG9ydCB7XG4gIGNzc0V2YWwsXG4gIGdldENzc0V2YWxzLFxuICBnZXRFbGVtZW50Q2xhc3NMaXN0LFxuICBwcm9jZXNzUnVsZXNGb3JTZWxlY3RlZEVsZW1lbnQsXG4gIHJ1bGVNYXRjaGVzRWxlbWVudCxcbiAgc2V0TW9kaWZpZXJzRm9yU2VsZWN0ZWRFbGVtZW50LFxufSBmcm9tICcuL2Nzc0Z1bmN0aW9ucyc7XG5pbXBvcnQge1xuICBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMsXG4gIFNFTEVDVF9PUl9IT1ZFUl9TVE9SWUJPQVJELFxuICBTVE9SWUJPQVJEX0hZRFJBVElPTl9TVEFUVVMsXG59IGZyb20gJy4vY29uc3RhbnRzQW5kVHlwZXMnO1xuaW1wb3J0IHtcbiAgQUREX0NMQVNTX0lOU1RBTlRfVVBEQVRFX1FVRVVFLFxuICBURU1QT1JBUllfU1RZTElOR19DTEFTU19OQU1FLFxuICBhcHBseUNoYW5nZUl0ZW1Ub0RvY3VtZW50LFxuICByZXNldEludGVybWVkaWF0ZUNsYXNzZXNGb3JTbGlkZXJJbnN0YW50VXBkYXRlLFxuICB1cGRhdGVDb2RlYmFzZUlkcyxcbiAgZ2V0RnVsbEh0bWxXaXRoRWxlbWVudCxcbn0gZnJvbSAnLi9jaGFuZ2VJdGVtRnVuY3Rpb25zJztcbmltcG9ydCB7IFRlbXBvRWxlbWVudCB9IGZyb20gJy4vdGVtcG9FbGVtZW50JztcbmltcG9ydCB7IEFueUNoYW5nZUxlZGdlckl0ZW0gfSBmcm9tICcuL2NoYW5nZUxlZGdlclR5cGVzJztcbmltcG9ydCB7XG4gIGNhbkVkaXRUZXh0LFxuICBjdXJyZW50bHlFZGl0aW5nLFxuICBnZXRFZGl0aW5nSW5mbyxcbiAgc2V0dXBFZGl0YWJsZVRleHQsXG4gIHRlYXJkb3duRWRpdGFibGVUZXh0LFxufSBmcm9tICcuL2VkaXRUZXh0VXRpbHMnO1xuaW1wb3J0IHsgRGVib3VuY2VFeGVjdXRvciB9IGZyb20gJy4uL3V0aWxzL0RlYm91bmNlRXhlY3V0b3InO1xuaW1wb3J0IHsgZGVmYXVsdFVJVXBkYXRlUnVubmVyLCBzbGVlcCB9IGZyb20gJy4vZG9tVXRpbHMnO1xuY29uc3QgUElYRUxTX1RPX01PVkVfQkVGT1JFX0RSQUcgPSAyMDtcblxuY29uc3QgSU1NRURJQVRFTFlfUkVNT1ZFX1BPSU5URVJfTE9DSyA9ICdJTU1FRElBVEVMWV9SRU1PVkVfUE9JTlRFUl9MT0NLJztcbmNvbnN0IExBU1RfTkFWX1RSRUVfUkVGUkVTSF9USU1FID0gJ0xBU1RfTkFWX1RSRUVfUkVGUkVTSF9USU1FJztcbmNvbnN0IExBU1RfU0VOVF9IT1ZFUkVEX0VMRU1FTlRfS0VZID0gJ0xBU1RfU0VOVF9IT1ZFUkVEX0VMRU1FTlRfS0VZJztcblxuaW1wb3J0IHsgdG9KcGVnIH0gZnJvbSAnaHRtbC10by1pbWFnZSc7XG5cbmNvbnN0IE1FU1NBR0VfVEhST1RUTEVfTVMgPSA1MDtcblxuLy8gVE9ETzogQ2hhbmdlIGFsbCBvZiB0aGlzIHRvIGJlIGEgcmVhY3Qgd3JhcHBlciBsaWJyYXJ5XG5cbmV4cG9ydCBjb25zdCBpbml0Q2hhbm5lbE1lc3NhZ2luZ0Z1bmN0aW9ucyA9ICgpID0+IHtcbiAgLy8gUHJldmVudCBtdWx0aXBsZSBpbml0aWFsaXphdGlvbnNcbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAod2luZG93LnRlbXBvSW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cudGVtcG9Jbml0aWFsaXplZCA9IHRydWU7XG5cbiAgcmVzZXRJbnRlcm1lZGlhdGVDbGFzc2VzRm9yU2xpZGVySW5zdGFudFVwZGF0ZSgpO1xuXG4gIC8vIEFsbCBwcm9jZXNzZXMgdGhhdCBpbnZvbHZlcyB1cGRhdGluZyB0aGUgVUkgc2hvdWxkIHVzZSB0aGlzIHJ1bm5lciB0byBhdm9pZCB0cmlnZ2VyaW5nIGEgY2FzY2FkZSBvZiB1cGRhdGVzXG4gIGxldCBnbG9iYWxVSVVwZGF0ZVJ1bm5lciA9IGRlZmF1bHRVSVVwZGF0ZVJ1bm5lcjtcblxuICAvLyBDcmVhdGUgdGhyb3R0bGVkIHBvc3QgbWVzc2FnZSBmdW5jdGlvbnMgcGVyIG1lc3NhZ2UgdHlwZVxuICBjb25zdCB0aHJvdHRsZWRQb3N0TWVzc2FnZUZ1bmN0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBGdW5jdGlvbj4oKTtcblxuICBjb25zdCB0aHJvdHRsZWRQb3N0TWVzc2FnZSA9IChwYXJlbnRQb3J0OiBhbnksIG1lc3NhZ2U6IGFueSkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gbWVzc2FnZS5pZDtcblxuICAgIGlmICghdGhyb3R0bGVkUG9zdE1lc3NhZ2VGdW5jdGlvbnMuaGFzKG1lc3NhZ2VUeXBlKSkge1xuICAgICAgY29uc3QgdGhyb3R0bGVkRm4gPSBfLnRocm90dGxlKFxuICAgICAgICAobXNnOiBhbnkpID0+IHBhcmVudFBvcnQucG9zdE1lc3NhZ2UobXNnKSxcbiAgICAgICAgTUVTU0FHRV9USFJPVFRMRV9NUyxcbiAgICAgICAgeyBsZWFkaW5nOiB0cnVlLCB0cmFpbGluZzogdHJ1ZSB9LFxuICAgICAgKTtcbiAgICAgIHRocm90dGxlZFBvc3RNZXNzYWdlRnVuY3Rpb25zLnNldChtZXNzYWdlVHlwZSwgdGhyb3R0bGVkRm4pO1xuICAgIH1cblxuICAgIGNvbnN0IHRocm90dGxlZEZuID0gdGhyb3R0bGVkUG9zdE1lc3NhZ2VGdW5jdGlvbnMuZ2V0KG1lc3NhZ2VUeXBlKTtcbiAgICB0aHJvdHRsZWRGbj8uKG1lc3NhZ2UpO1xuICB9O1xuXG4gIC8vIG9ubHkgc2VuZHMgbWVzc2FnZSBmb3IgSE9WRVJFRF9FTEVNRU5UX0tFWSB3aGVuIHZhbHVlIGNoYW5nZXNcbiAgY29uc3Qgc2VuZEhvdmVyZWRFbGVtZW50S2V5TWVzc2FnZSA9IChwYXJlbnRQb3J0OiBhbnksIGVsZW1lbnRLZXk6IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICBjb25zdCBsYXN0U2VudEtleSA9IGdldE1lbW9yeVN0b3JhZ2VJdGVtKExBU1RfU0VOVF9IT1ZFUkVEX0VMRU1FTlRfS0VZKTtcbiAgICBcbiAgICAvLyBPbmx5IHNlbmQgbWVzc2FnZSBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICBpZiAobGFzdFNlbnRLZXkgIT09IGVsZW1lbnRLZXkpIHtcbiAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpZDogRklYRURfSUZSQU1FX01FU1NBR0VfSURTLkhPVkVSRURfRUxFTUVOVF9LRVksXG4gICAgICAgIGVsZW1lbnRLZXk6IGVsZW1lbnRLZXksXG4gICAgICB9KTtcbiAgICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKExBU1RfU0VOVF9IT1ZFUkVEX0VMRU1FTlRfS0VZLCBlbGVtZW50S2V5KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICBTdHJpbmcucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNoID0gMCxcbiAgICAgIGksXG4gICAgICBjaHI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gaGFzaDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hyID0gdGhpcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNocjtcbiAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xuICB9O1xuXG4gIC8vIFdlIHdhbnQgdG8gbWFrZSBldmVudCBsaXN0ZW5lcnMgbm9uLXBhc3NpdmUsIGFuZCB0byBkbyBzbyBoYXZlIHRvIGNoZWNrXG4gIC8vIHRoYXQgYnJvd3NlcnMgc3VwcG9ydCBFdmVudExpc3RlbmVyT3B0aW9ucyBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1NhZmVseV9kZXRlY3Rpbmdfb3B0aW9uX3N1cHBvcnRcbiAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcblxuICBjb25zdCBtYWtlUGFzc2l2ZUV2ZW50T3B0aW9uID0gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXJcbiAgICAgICAgICAvLyAgIGF0dGVtcHRzIHRvIGFjY2VzcyB0aGUgcGFzc2l2ZSBwcm9wZXJ0eS5cbiAgICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGFrZW4gZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzIxOTc1OC9kZXRlY3QtY2hhbmdlcy1pbi10aGUtZG9tXG4gICAqXG4gICAqIFJldHVybnMgdGhlIGZ1bmN0aW9uIHRvIGRpc2Nvbm5lY3QgdGhlIG9ic2VydmVyXG4gICAqL1xuICBjb25zdCBvYnNlcnZlRE9NID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFyIE11dGF0aW9uT2JzZXJ2ZXIgPVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG9ianM6IEhUTUxFbGVtZW50W10sIGNhbGxiYWNrOiAobXV0YXRpb25zOiBhbnkpID0+IHZvaWQpIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkT2JqcyA9IG9ianMuZmlsdGVyKChvYmopID0+IG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuXG4gICAgICBpZiAoZmlsdGVyZWRPYmpzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFVJVXBkYXRlUnVubmVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgbXV0YXRpb25PYnNlcnZlcjogTXV0YXRpb25PYnNlcnZlcjtcblxuICAgICAgY29uc3QgdWlVcGRhdGVSdW5uZXIgPSAoaW5uZXJTY29wZTogKCkgPT4gdm9pZCkgPT4ge1xuICAgICAgICAvLyBQYXVzZSB0aGUgb2JzZXJ2ZXJcbiAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlubmVyU2NvcGUoKTtcblxuICAgICAgICAvLyBSZXN1bWUgdGhlIG9ic2VydmVyXG4gICAgICAgIGlmIChtdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgZmlsdGVyZWRPYmpzLmZvckVhY2goKG9iaikgPT4ge1xuICAgICAgICAgICAgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKG9iaiwge1xuICAgICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjayk7XG5cbiAgICAgICAgZmlsdGVyZWRPYmpzLmZvckVhY2goKG9iaikgPT4ge1xuICAgICAgICAgIC8vIGhhdmUgdGhlIG9ic2VydmVyIG9ic2VydmUgZm9vIGZvciBjaGFuZ2VzIGluIGNoaWxkcmVuXG4gICAgICAgICAgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKG9iaiwge1xuICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGJyb3dzZXIgc3VwcG9ydCBmYWxsYmFja1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZWxzZSBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgZmlsdGVyZWRPYmpzLmZvckVhY2goKG9iaikgPT4ge1xuICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlSW5zZXJ0ZWQnLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlUmVtb3ZlZCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdWlVcGRhdGVSdW5uZXI7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogV2hlbiBzZWxlY3RpbmcgaW4gbm9ybWFsIG1vZGUgKG5vdCBtZXRhIGtleSksIGNhbiBzZWxlY3Qgb25lIGxldmVsIGRvd24sIGEgc2libGluZ1xuICAgKiBvciBhIHBhcmVudCBvZiB0aGUgc2VsZWN0ZWQgZWxlbWVudFxuICAgKi9cbiAgY29uc3QgZ2V0U2VsZWN0YWJsZU5hdk5vZGUgPSAoZTogYW55KTogTmF2VHJlZU5vZGUgfCBudWxsIHwgc3RyaW5nID0+IHtcbiAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnRLZXk6IHN0cmluZyA9XG4gICAgICBnZXRNZW1vcnlTdG9yYWdlSXRlbShTRUxFQ1RFRF9FTEVNRU5UX0tFWSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gVGVtcG9FbGVtZW50LmZyb21LZXkoc2VsZWN0ZWRFbGVtZW50S2V5KTtcblxuICAgIGNvbnN0IGVsZW1lbnRLZXlUb05hdk5vZGUgPSBnZXRNZW1vcnlTdG9yYWdlSXRlbShFTEVNRU5UX0tFWV9UT19OQVZfTk9ERSk7XG5cbiAgICAvLyBNb3ZlIHVwIHRoZSB0cmVlIHVudGlsIHlvdSBmaW5kIHRoZSBmaXJzdCB2YWxpZCBuYXYgbm9kZVxuICAgIGxldCBmaXJzdE5hdk5vZGU6IE5hdlRyZWVOb2RlIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHNlYXJjaE5vZGUgPSBlLnRhcmdldDtcbiAgICB3aGlsZSAoc2VhcmNoTm9kZSAmJiAhZmlyc3ROYXZOb2RlKSB7XG4gICAgICBmaXJzdE5hdk5vZGUgPVxuICAgICAgICBlbGVtZW50S2V5VG9OYXZOb2RlW2dldEVsZW1lbnRLZXlGcm9tTm9kZShzZWFyY2hOb2RlKSB8fCAnJ107XG4gICAgICBzZWFyY2hOb2RlID0gc2VhcmNoTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cblxuICAgIGlmICghZmlyc3ROYXZOb2RlKSB7XG4gICAgICByZXR1cm4gU0VMRUNUX09SX0hPVkVSX1NUT1JZQk9BUkQ7XG4gICAgfVxuXG4gICAgY29uc3QgaXNOYXZOb2RlTWF0Y2ggPSAobmF2VHJlZU5vZGU6IE5hdlRyZWVOb2RlKTogYm9vbGVhbiA9PiB7XG4gICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50LmlzRW1wdHkoKSkge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNhbm5vdCBiZSBjYWxsZWQgaWYgdGhlcmUgaXMgbm8gc2VsZWN0ZWQgZWxlbWVudCwgc2VlIGNvZGUgbG9naWMgYmVsb3cgdGhlIGZ1bmN0aW9uXG4gICAgICAgIHRocm93IEVycm9yKCdObyBzZWxlY3RlZCBlbGVtZW50IHdoZW4gaXNOYXZOb2RlTWF0Y2ggY2FsbGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbmF2VHJlZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBjb2RlYmFzZSBJRCBpdCBzaG91bGQgbm90IGJlIHNlbGVjdGFibGUgYXMgdGhlcmUgaXMgbm90aGluZyB3ZSBjYW4gZG8gd2l0aCBpdFxuICAgICAgaWYgKFxuICAgICAgICAhbmF2VHJlZU5vZGUudGVtcG9FbGVtZW50LmNvZGViYXNlSWQuc3RhcnRzV2l0aCgndGVtcG8tJykgfHxcbiAgICAgICAgbmF2VHJlZU5vZGUudGVtcG9FbGVtZW50LmNvZGViYXNlSWQgPT09IFNLSVBfUk9PVF9DT0RFQkFTRV9JRFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgbWF0Y2hlcywgd2UgYWxyZWFkeSBwYXNzZWQgYWxsIHBvc3NpYmxlIGNoaWxkcmVuLCBzbyByZS1zZWxlY3QgaXRcbiAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnQuaXNFcXVhbChuYXZUcmVlTm9kZS50ZW1wb0VsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBBbnkgcGFyZW50IGlzIG9rIHRvIHNlbGVjdFxuICAgICAgaWYgKG5hdlRyZWVOb2RlLnRlbXBvRWxlbWVudC5pc1BhcmVudE9mKHNlbGVjdGVkRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHBhcmVudHNcbiAgICAgIC8vIFBpY2sgdGhlIGZpcnN0IHBhcmVudCB3aXRoIGEgY29kZWJhc2UgSURcbiAgICAgIGxldCBwYXJlbnQgPSBuYXZUcmVlTm9kZS5wYXJlbnQ7XG4gICAgICB3aGlsZSAocGFyZW50ICYmICFwYXJlbnQudGVtcG9FbGVtZW50LmNvZGViYXNlSWQuc3RhcnRzV2l0aCgndGVtcG8tJykpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgLy8gT25lIGxldmVsIGRvd25cbiAgICAgIGlmIChwYXJlbnQ/LnRlbXBvRWxlbWVudD8uaXNFcXVhbChzZWxlY3RlZEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTaWJsaW5nIG9mIGFueSBwYXJlbnRcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IGVsZW1lbnRLZXlUb05hdk5vZGVbc2VsZWN0ZWRFbGVtZW50LmdldEtleSgpXTtcbiAgICAgIGlmIChcbiAgICAgICAgc2VsZWN0ZWROb2RlICYmXG4gICAgICAgIG5hdlRyZWVOb2RlLnBhcmVudD8uY2hpbGRyZW4/LmluY2x1ZGVzPy4oc2VsZWN0ZWROb2RlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGxldCBmb3VuZE5hdk5vZGU6IE5hdlRyZWVOb2RlIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHNlYXJjaE5hdk5vZGU6IE5hdlRyZWVOb2RlIHwgdW5kZWZpbmVkID0gZmlyc3ROYXZOb2RlO1xuXG4gICAgd2hpbGUgKHNlYXJjaE5hdk5vZGUpIHtcbiAgICAgIGlmICghc2VsZWN0ZWRFbGVtZW50LmlzRW1wdHkoKSAmJiAhc2VsZWN0ZWRFbGVtZW50LmlzU3Rvcnlib2FyZCgpKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgc2VsZWN0ZWQgZWxlbWVudCBrZXkgbG9vcCBmcm9tIHRoaXMgZWxlbWVudCB1cCB0aGUgc3RhY2sgdG8gZmluZCB0aGUgZWxlbWVudCB0aGF0IGlzIHRoZSBkaXJlY3QgY2hpbGRcbiAgICAgICAgLy8gb2YgdGhlIGV4cGVjdGVkIHNlbGVjdGVkIGVsZW1lbnQsIHNvIHRoYXQgeW91IGNhbiBvbmx5IGhvdmVyIG9uZSBsZXZlbCBkZWVwZXIgdGhhbiB5b3UndmUgc2VsZWN0ZWRcbiAgICAgICAgaWYgKGlzTmF2Tm9kZU1hdGNoKHNlYXJjaE5hdk5vZGUpKSB7XG4gICAgICAgICAgZm91bmROYXZOb2RlID0gc2VhcmNoTmF2Tm9kZTtcbiAgICAgICAgICAvLyBFeGl0IHRoZSBsb29wIGFzIHdlIGZvdW5kIHRoZSBub2RlIHRoYXQgbWF0Y2hlc1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzZWxlY3RlZCBlbGVtZW50IGtleSwgb3IgdGhlIHNlbGVjdGlvbiBpcyB0aGUgc3Rvcnlib2FyZCBpdHNlbGYsIGxvb3AgdXAgdG8gdGhlIHRvcC1tb3N0IGVsZW1lbnQgd2l0aCBhIGNvZGViYXNlIElEXG4gICAgICAgIGlmIChcbiAgICAgICAgICBzZWFyY2hOYXZOb2RlLnRlbXBvRWxlbWVudC5jb2RlYmFzZUlkPy5zdGFydHNXaXRoKCd0ZW1wby0nKVxuICAgICAgICApIHtcbiAgICAgICAgICBmb3VuZE5hdk5vZGUgPSBzZWFyY2hOYXZOb2RlO1xuICAgICAgICAgIC8vIE5vdGU6IHdlIGRvIG5vdCBleGl0IHRoZSBsb29wIGhlcmUgYXMgd2Ugd2FudCB0byBrZWVwIHNlYXJjaGluZyBmb3IgdGhlIHRvcC1tb3N0IGVsZW1lbnRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWFyY2hOYXZOb2RlID0gc2VhcmNoTmF2Tm9kZS5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvdW5kTmF2Tm9kZSB8fCBudWxsO1xuICB9O1xuXG4gIGNvbnN0IG9uUG9pbnRlck92ZXIgPSAoXG4gICAgZTogYW55LFxuICAgIHBhcmVudFBvcnQ6IGFueSxcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZyxcbiAgICBzZWxlY3RCb3R0b21Nb3N0RWxlbWVudD86IGJvb2xlYW4sXG4gICkgPT4ge1xuICAgIGNvbnN0IHBhc3NlZFRocm91Z2ggPSBwYXNzVGhyb3VnaEV2ZW50c0lmTmVlZGVkKFxuICAgICAgZSxcbiAgICAgIHBhcmVudFBvcnQsXG4gICAgICBzdG9yeWJvYXJkSWQsXG4gICAgKTtcbiAgICBjb25zdCBlZGl0aW5nVGV4dEluZm8gPSBnZXRFZGl0aW5nSW5mbygpO1xuXG4gICAgLy8gQWxsb3cgb24gcG9pbnRlciBvdmVyIGV2ZW50cyBpZiBlZGl0aW5nIChzbyB3ZSBjYW4gY2xpY2sgb3V0KVxuICAgIGlmIChlLmFsdEtleSB8fCAocGFzc2VkVGhyb3VnaCAmJiAhZWRpdGluZ1RleHRJbmZvKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChnZXRNZW1vcnlTdG9yYWdlSXRlbSgnbW91c2VEcmFnQ29udGV4dCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudEhvdmVyZWRLZXkgPSBnZXRNZW1vcnlTdG9yYWdlSXRlbShIT1ZFUkVEX0VMRU1FTlRfS0VZKTtcblxuICAgIGNvbnN0IGVsZW1lbnRLZXlUb05hdk5vZGUgPVxuICAgICAgZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oRUxFTUVOVF9LRVlfVE9fTkFWX05PREUpIHx8IHt9O1xuXG4gICAgbGV0IGhvdmVyZWROYXZOb2RlOiBOYXZUcmVlTm9kZSB8IG51bGwgfCBzdHJpbmc7XG4gICAgaWYgKGUubWV0YUtleSB8fCBlLmN0cmxLZXkgfHwgc2VsZWN0Qm90dG9tTW9zdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRLZXk6IGFueSA9IGdldEVsZW1lbnRLZXlGcm9tTm9kZShlLnRhcmdldCk7XG4gICAgICBob3ZlcmVkTmF2Tm9kZSA9IGVsZW1lbnRLZXlUb05hdk5vZGVbZWxlbWVudEtleV07XG5cbiAgICAgIC8vIFNwZWNpYWwgY2FzZSAtPiB0aGlzIGlzIHRoZSB0b3AtbW9zdCBub2RlIHNvIGl0IHNob3VsZCB0cmlnZ2VyIGEgaG92ZXIgb24gdGhlIHN0b3J5Ym9hcmRcbiAgICAgIGlmICghaG92ZXJlZE5hdk5vZGUgJiYgZS50YXJnZXQucGFyZW50Tm9kZSA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBob3ZlcmVkTmF2Tm9kZSA9IFNFTEVDVF9PUl9IT1ZFUl9TVE9SWUJPQVJEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBob3ZlcmVkTmF2Tm9kZSA9IGdldFNlbGVjdGFibGVOYXZOb2RlKGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRTZWxlY3RlZEtleSA9IGdldE1lbW9yeVN0b3JhZ2VJdGVtKFNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcbiAgICBjb25zdCBjdXJyZW50U2VsZWN0ZWRFbGVtZW50ID0gVGVtcG9FbGVtZW50LmZyb21LZXkoY3VycmVudFNlbGVjdGVkS2V5KTtcblxuICAgIC8vIElmIHRoZSB1c2VyIGlzIGhvbGRpbmcgc2hpZnQsIG9ubHkgYWxsb3cgc2VsZWN0aW5nIHNpYmxpbmdzXG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgaG92ZXJlZE5hdk5vZGUgJiYgY3VycmVudFNlbGVjdGVkS2V5KSB7XG4gICAgICAvLyBUcnlpbmcgdG8gc2VsZWN0IHRoZSBlbnRpcmUgc3Rvcnlib2FyZCwgYWxsb3cgb25seSBpZiB0aGUgb3RoZXIgc2VsZWN0ZWQgZWxlbWVudCBpcyBhbHNvIGEgc3Rvcnlib2FyZFxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgaG92ZXJlZE5hdk5vZGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICFjdXJyZW50U2VsZWN0ZWRFbGVtZW50LmlzU3Rvcnlib2FyZCgpXG4gICAgICApIHtcbiAgICAgICAgaG92ZXJlZE5hdk5vZGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBob3ZlcmVkTmF2Tm9kZSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgIWhvdmVyZWROYXZOb2RlPy50ZW1wb0VsZW1lbnQuaXNTaWJsaW5nT2YoY3VycmVudFNlbGVjdGVkRWxlbWVudClcbiAgICAgICkge1xuICAgICAgICBob3ZlcmVkTmF2Tm9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFob3ZlcmVkTmF2Tm9kZSkge1xuICAgICAgaWYgKGN1cnJlbnRIb3ZlcmVkS2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKEhPVkVSRURfRUxFTUVOVF9LRVksIG51bGwpO1xuICAgICAgICBzZW5kSG92ZXJlZEVsZW1lbnRLZXlNZXNzYWdlKHBhcmVudFBvcnQsIG51bGwpO1xuXG4gICAgICAgIHVwZGF0ZU91dGxpbmVzKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhvdmVyZWROYXZOb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGhvdmVyZWROYXZOb2RlID09PSBTRUxFQ1RfT1JfSE9WRVJfU1RPUllCT0FSRCkge1xuICAgICAgICBjb25zdCBzdG9yeWJvYXJkS2V5ID0gVGVtcG9FbGVtZW50LmZvclN0b3J5Ym9hcmQoc3Rvcnlib2FyZElkKS5nZXRLZXkoKTtcblxuICAgICAgICBpZiAoY3VycmVudEhvdmVyZWRLZXkgIT09IHN0b3J5Ym9hcmRLZXkpIHtcbiAgICAgICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbShIT1ZFUkVEX0VMRU1FTlRfS0VZLCBzdG9yeWJvYXJkS2V5KTtcblxuICAgICAgICAgIHNlbmRIb3ZlcmVkRWxlbWVudEtleU1lc3NhZ2UocGFyZW50UG9ydCwgc3Rvcnlib2FyZEtleSk7XG5cbiAgICAgICAgICB1cGRhdGVPdXRsaW5lcyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0ZW1wb0VsZW1lbnRLZXkgPSBob3ZlcmVkTmF2Tm9kZS50ZW1wb0VsZW1lbnQuZ2V0S2V5KCk7XG5cbiAgICBpZiAoY3VycmVudEhvdmVyZWRLZXkgIT09IHRlbXBvRWxlbWVudEtleSkge1xuICAgICAgc2VuZEhvdmVyZWRFbGVtZW50S2V5TWVzc2FnZShwYXJlbnRQb3J0LCB0ZW1wb0VsZW1lbnRLZXkpO1xuICAgICAgc2V0TWVtb3J5U3RvcmFnZUl0ZW0oSE9WRVJFRF9FTEVNRU5UX0tFWSwgdGVtcG9FbGVtZW50S2V5KTtcbiAgICAgIHVwZGF0ZU91dGxpbmVzKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNsZWFySG92ZXJlZEVsZW1lbnRzID0gKHBhcmVudFBvcnQ6IGFueSwgc3Rvcnlib2FyZElkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBjdXJyZW50SG92ZXJlZEtleSA9IGdldE1lbW9yeVN0b3JhZ2VJdGVtKEhPVkVSRURfRUxFTUVOVF9LRVkpO1xuXG4gICAgaWYgKCFjdXJyZW50SG92ZXJlZEtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbmRIb3ZlcmVkRWxlbWVudEtleU1lc3NhZ2UocGFyZW50UG9ydCwgbnVsbCk7XG4gICAgc2V0TWVtb3J5U3RvcmFnZUl0ZW0oSE9WRVJFRF9FTEVNRU5UX0tFWSwgbnVsbCk7XG5cbiAgICB1cGRhdGVPdXRsaW5lcyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICB9O1xuXG4gIGNvbnN0IG9uUG9pbnRlck1vdmUgPSBhc3luYyAoXG4gICAgZTogYW55LFxuICAgIHBhcmVudFBvcnQ6IGFueSxcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZyxcbiAgKSA9PiB7XG4gICAgcGFzc1Rocm91Z2hFdmVudHNJZk5lZWRlZChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuXG4gICAgLy8gSWYgbm8gYnV0dG9ucyBhcmUgcHJlc3NlZCB0aGUgZHJhZyBlbmQgZXZlbnQgbWF5IG5vdCBoYXZlIGNvcnJlY3RseSB0cmlnZ2VyZWRcbiAgICAvLyByZXNldCB0aGUgZHJhZyBzdGF0ZVxuICAgIGxldCBtb3VzZURyYWdEYXRhID0gZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oJ21vdXNlRHJhZ0NvbnRleHQnKTtcbiAgICBpZiAoIWUuYnV0dG9ucyAmJiBtb3VzZURyYWdEYXRhKSB7XG4gICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbSgnbW91c2VEcmFnQ29udGV4dCcsIG51bGwpO1xuXG4gICAgICBpZiAobW91c2VEcmFnRGF0YT8uZHJhZ2dpbmcpIHtcbiAgICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgaWQ6IEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5EUkFHX0NBTkNFTF9FVkVOVCxcbiAgICAgICAgICBldmVudDoge30sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBtb3VzZURyYWdEYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBpbXBvcnRhbnRGaWVsZHMgPSB7XG4gICAgICBwYWdlWDogZS5wYWdlWCxcbiAgICAgIHBhZ2VZOiBlLnBhZ2VZLFxuXG4gICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBlLmNsaWVudFksXG4gICAgfTtcblxuICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKCdtb3VzZVBvcycsIGltcG9ydGFudEZpZWxkcyk7XG5cbiAgICB0aHJvdHRsZWRQb3N0TWVzc2FnZShwYXJlbnRQb3J0LCB7XG4gICAgICBpZDogRklYRURfSUZSQU1FX01FU1NBR0VfSURTLk1PVVNFX01PVkVfRVZFTlQsXG4gICAgICBldmVudDogaW1wb3J0YW50RmllbGRzLFxuICAgIH0pO1xuXG4gICAgaWYgKG1vdXNlRHJhZ0RhdGEgJiYgIW1vdXNlRHJhZ0RhdGEuZHJhZ2dpbmcpIHtcbiAgICAgIGNvbnN0IHpvb21QZXJjID0gZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oJ3pvb21QZXJjJykgfHwgMTtcblxuICAgICAgY29uc3QgdG90YWxNb3ZlbWVudFBpeGVscyA9XG4gICAgICAgIE1hdGguYWJzKG1vdXNlRHJhZ0RhdGEucGFnZVggLSBlLnBhZ2VYKSArXG4gICAgICAgIE1hdGguYWJzKG1vdXNlRHJhZ0RhdGEucGFnZVkgLSBlLnBhZ2VZKTtcbiAgICAgIC8vIFN0YXJ0IHRoZSBkcmFnIGV2ZW50IGlmIHRoZSB1c2VyIGhhcyBtb3ZlZCBlbm91Z2hcbiAgICAgIGlmICh0b3RhbE1vdmVtZW50UGl4ZWxzID49IFBJWEVMU19UT19NT1ZFX0JFRk9SRV9EUkFHIC8gem9vbVBlcmMpIHtcbiAgICAgICAgLy8gUmVzZWxlY3QgdGhlIHBhcmVudCBpZiB0aGVyZSB3YXMgb25lIHRvIHNlbGVjdFxuICAgICAgICBpZiAobW91c2VEcmFnRGF0YS5wYXJlbnRTZWxlY3RlZEVsZW1lbnRLZXkpIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50S2V5VG9OYXZOb2RlID1cbiAgICAgICAgICAgIGdldE1lbW9yeVN0b3JhZ2VJdGVtKEVMRU1FTlRfS0VZX1RPX05BVl9OT0RFKSB8fCB7fTtcbiAgICAgICAgICBjb25zdCBuYXZOb2RlVG9TZWxlY3QgPVxuICAgICAgICAgICAgZWxlbWVudEtleVRvTmF2Tm9kZVttb3VzZURyYWdEYXRhLnBhcmVudFNlbGVjdGVkRWxlbWVudEtleV07XG5cbiAgICAgICAgICBpZiAobmF2Tm9kZVRvU2VsZWN0KSB7XG4gICAgICAgICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgaWQ6IEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5TRUxFQ1RFRF9FTEVNRU5UX0tFWSxcbiAgICAgICAgICAgICAgZWxlbWVudEtleTogbW91c2VEcmFnRGF0YS5wYXJlbnRTZWxlY3RlZEVsZW1lbnRLZXksXG4gICAgICAgICAgICAgIG91dGVySFRNTDogZ2V0RnVsbEh0bWxXaXRoRWxlbWVudChbXG4gICAgICAgICAgICAgICAgbW91c2VEcmFnRGF0YS5wYXJlbnRTZWxlY3RlZEVsZW1lbnRLZXksXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbShcbiAgICAgICAgICAgICAgU0VMRUNURURfRUxFTUVOVF9LRVksXG4gICAgICAgICAgICAgIG1vdXNlRHJhZ0RhdGEucGFyZW50U2VsZWN0ZWRFbGVtZW50S2V5LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhaUNvbnRleHRTZWxlY3Rpb24gPSBnZXRNZW1vcnlTdG9yYWdlSXRlbSgnYWlDb250ZXh0Jyk7XG5cbiAgICAgICAgLy8gRG9uJ3QgZW5hYmxlIGRyYWdnaW5nIGlmIHRoZSBBSSBjb250ZXh0IGlzIGVuYWJsZWRcbiAgICAgICAgaWYgKCFhaUNvbnRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbSgnbW91c2VEcmFnQ29udGV4dCcsIHtcbiAgICAgICAgICAgIC4uLm1vdXNlRHJhZ0RhdGEsXG4gICAgICAgICAgICBkcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkRWxlbWVudEtleSA9IGdldE1lbW9yeVN0b3JhZ2VJdGVtKFNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcblxuICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIGRyYWcgc3RhcnQgZXZlbnRcbiAgICAgICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuRFJBR19TVEFSVF9FVkVOVCxcbiAgICAgICAgICAgIGV2ZW50OiBtb3VzZURyYWdEYXRhLFxuICAgICAgICAgICAgb3V0ZXJIVE1MOiBnZXRGdWxsSHRtbFdpdGhFbGVtZW50KFtzZWxlY3RlZEVsZW1lbnRLZXldKSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IGJvZHlPYmplY3QgPSAkKCdib2R5JykuZ2V0KDApO1xuXG4gICAgICAgICAgLy8gSEFDSzogTWFyY2ggOCwgMjAyNFxuICAgICAgICAgIC8vIFdpdGhvdXQgdGhpcyB3b3JrYXJvdW5kIGV2ZW50cyBzdGF5IGluc2lkZSB0aGUgaWZyYW1lIHNvIGl0J3Mgbm90IHBvc3NpYmxlIHRvXG4gICAgICAgICAgLy8gdHJhY2sgbW91c2UgbW92ZW1lbnRzIG91dHNpZGUgdGhlIGlmcmFtZSB3aGVuIGNsaWNraW5nICYgZHJhZ2dpbmcuXG4gICAgICAgICAgLy8gU2V0IHRoZSBwb2ludGVyIGxvY2sgYW5kIGltbWVkaWF0ZWx5IHJlbW92ZSBpdCBzbyB0aGF0XG4gICAgICAgICAgLy8gdGhlIGV2ZW50cyBzdGFydCB0byBwcm9wYWdhdGUgdXB3YXJkcyBpbiB0aGUgb3V0ZXIgYXBwbGljYXRpb24uXG4gICAgICAgICAgc2V0TWVtb3J5U3RvcmFnZUl0ZW0oSU1NRURJQVRFTFlfUkVNT1ZFX1BPSU5URVJfTE9DSywgdHJ1ZSk7XG4gICAgICAgICAgYXdhaXQgYm9keU9iamVjdD8ucmVxdWVzdFBvaW50ZXJMb2NrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oJ21vdXNlRHJhZ0NvbnRleHQnKSkge1xuICAgICAgdXBkYXRlT3V0bGluZXMocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZ2V0UGFyZW50RG9tRWxlbWVudEZvck5hdk5vZGUgPSAobmF2Tm9kZTogTmF2VHJlZU5vZGUpID0+IHtcbiAgICBpZiAoIW5hdk5vZGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghbmF2Tm9kZT8uaXNDb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IGNoaWxkRG9tRWxlbWVudCA9IGdldE5vZGVGb3JFbGVtZW50S2V5KFxuICAgICAgICBuYXZOb2RlLnRlbXBvRWxlbWVudC5nZXRLZXkoKSxcbiAgICAgICk7XG4gICAgICByZXR1cm4gY2hpbGREb21FbGVtZW50Py5wYXJlbnRFbGVtZW50O1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgdGhlIGxpc3Qgb2YgcmVhbCBET00gZWxlbWVudHMgdGhhdCBhcmUgYXQgdGhlIHRvcCBsZXZlbCBvZiB0aGlzIGNvbXBvbmVudFxuICAgIGNvbnN0IGVsZW1lbnRLZXlUb0xvb2t1cExpc3Q6IGFueSA9XG4gICAgICBnZXRNZW1vcnlTdG9yYWdlSXRlbShFTEVNRU5UX0tFWV9UT19MT09LVVBfTElTVCkgfHwge307XG5cbiAgICBjb25zdCBsb29rdXBMaXN0ID1cbiAgICAgIGVsZW1lbnRLZXlUb0xvb2t1cExpc3RbbmF2Tm9kZS50ZW1wb0VsZW1lbnQuZ2V0S2V5KCldIHx8IFtdO1xuICAgIGxldCBjaGlsZERvbUVsZW1lbnQ6IGFueTtcbiAgICBsb29rdXBMaXN0LmZvckVhY2goKGxvb2t1cEVsZW1lbnRLZXk6IHN0cmluZykgPT4ge1xuICAgICAgaWYgKGNoaWxkRG9tRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNoaWxkRG9tRWxlbWVudCA9IGdldE5vZGVGb3JFbGVtZW50S2V5KGxvb2t1cEVsZW1lbnRLZXkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNoaWxkRG9tRWxlbWVudD8ucGFyZW50RWxlbWVudDtcbiAgfTtcblxuICBjb25zdCBvblBvaW50ZXJEb3duID0gKGU6IGFueSwgcGFyZW50UG9ydDogYW55LCBzdG9yeWJvYXJkSWQ6IHN0cmluZykgPT4ge1xuICAgIC8vIFRoaXMgdmFyaWFibGUgZGV0ZXJtaW5lcyB3aGljaCBidXR0b24gd2FzIHVzZWRcbiAgICAvLyAxIC0+IGxlZnQsIDIgLT4gbWlkZGxlLCAzIC0+IHJpZ2h0XG4gICAgaWYgKGUud2hpY2ggIT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBbGxvdyB0aGUgZWRpdCBkeW5hbWljIHRleHQgYnV0dG9uIHRvIGJlIGNsaWNrZWRcbiAgICBpZiAoaGFzQ2xhc3MoZS50YXJnZXQsIEVESVRfVEVYVF9CVVRUT04pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFzc2VkVGhyb3VnaCA9IHBhc3NUaHJvdWdoRXZlbnRzSWZOZWVkZWQoXG4gICAgICBlLFxuICAgICAgcGFyZW50UG9ydCxcbiAgICAgIHN0b3J5Ym9hcmRJZCxcbiAgICApO1xuICAgIGlmIChwYXNzZWRUaHJvdWdoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50S2V5ID0gZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oU0VMRUNURURfRUxFTUVOVF9LRVkpO1xuICAgIGNvbnN0IHNlbGVjdGVkRWxlbWVudCA9IFRlbXBvRWxlbWVudC5mcm9tS2V5KHNlbGVjdGVkRWxlbWVudEtleSk7XG4gICAgY29uc3Qgc2VsZWN0ZWROYXZOb2RlID0gb25TZWxlY3RFbGVtZW50KGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG5cbiAgICBjb25zdCB1c2VTZWxlY3RlZElmRHJhZ2dpbmcgPVxuICAgICAgIXNlbGVjdGVkRWxlbWVudC5pc0VtcHR5KCkgJiZcbiAgICAgIHNlbGVjdGVkRWxlbWVudC5pc1BhcmVudE9mKHNlbGVjdGVkTmF2Tm9kZT8udGVtcG9FbGVtZW50KTtcblxuICAgIGxldCBvZmZzZXRYLCBvZmZzZXRZO1xuXG4gICAgaWYgKHNlbGVjdGVkTmF2Tm9kZT8ucGFnZUJvdW5kaW5nQm94KSB7XG4gICAgICBvZmZzZXRYID1cbiAgICAgICAgc2VsZWN0ZWROYXZOb2RlLnBhZ2VCb3VuZGluZ0JveC5wYWdlWCArXG4gICAgICAgIHNlbGVjdGVkTmF2Tm9kZS5wYWdlQm91bmRpbmdCb3gud2lkdGggLyAyIC1cbiAgICAgICAgZS5wYWdlWDtcbiAgICAgIG9mZnNldFkgPVxuICAgICAgICBzZWxlY3RlZE5hdk5vZGUucGFnZUJvdW5kaW5nQm94LnBhZ2VZICtcbiAgICAgICAgc2VsZWN0ZWROYXZOb2RlLnBhZ2VCb3VuZGluZ0JveC5oZWlnaHQgLyAyIC1cbiAgICAgICAgZS5wYWdlWTtcbiAgICB9XG5cbiAgICBjb25zdCBpbXBvcnRhbnRGaWVsZHM6IGFueSA9IHtcbiAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgcGFnZVk6IGUucGFnZVksXG5cbiAgICAgIC8vIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gd2hlcmUgdGhlIHVzZXIgY2xpY2tlZCBhbmQgdGhlIGNlbnRlciBvZiB0aGUgZWxlbWVudFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG5cbiAgICAgIC8vIFVzZWQgdG8gcmVzZWxlY3QgdGhlIHBhcmVudCBpZiB0aGUgdXNlciBzdGFydHMgdG8gbW92ZVxuICAgICAgcGFyZW50U2VsZWN0ZWRFbGVtZW50S2V5OiB1c2VTZWxlY3RlZElmRHJhZ2dpbmdcbiAgICAgICAgPyBzZWxlY3RlZEVsZW1lbnRLZXlcbiAgICAgICAgOiBudWxsLFxuICAgIH07XG5cbiAgICBjb25zdCBlbGVtZW50S2V5VG9OYXZOb2RlID1cbiAgICAgIGdldE1lbW9yeVN0b3JhZ2VJdGVtKEVMRU1FTlRfS0VZX1RPX05BVl9OT0RFKSB8fCB7fTtcblxuICAgIC8vIEdldCB0aGUgcGFyZW50IGVsZW1lbnQgKGFjdHVhbCBET00gZWxlbWVudCkgdGhhdCB0aGlzIG5vZGUgaXMgYmVpbmcgZHJhZ2dlZCBpbnNpZGVcbiAgICAvLyBUbyBkbyB0aGlzIHBpY2sgb25lIGNoaWxkIGVsZW1lbnQgdGhhdCBpcyBiZWluZyBkcmFnZ2VkIChjYW4gYmUgbXVsdGlwbGUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgYmVpbmcgZHJhZ2dlZCBpcyBhIGNvbXBvbmVudCksXG4gICAgLy8gYW5kIGdldCBpdHMgcGFyZW50IGluIHRoZSBET01cbiAgICBjb25zdCBuYXZOb2RlVG9Vc2VGb3JEcmFnZ2luZyA9IHVzZVNlbGVjdGVkSWZEcmFnZ2luZ1xuICAgICAgPyBlbGVtZW50S2V5VG9OYXZOb2RlW3NlbGVjdGVkRWxlbWVudEtleV1cbiAgICAgIDogc2VsZWN0ZWROYXZOb2RlO1xuXG4gICAgY29uc3QgcGFyZW50RG9tRWxlbWVudCA9IGdldFBhcmVudERvbUVsZW1lbnRGb3JOYXZOb2RlKFxuICAgICAgbmF2Tm9kZVRvVXNlRm9yRHJhZ2dpbmcsXG4gICAgKTtcblxuICAgIGlmIChwYXJlbnREb21FbGVtZW50KSB7XG4gICAgICBpbXBvcnRhbnRGaWVsZHNbJ3NlbGVjdGVkUGFyZW50RGlzcGxheSddID0gY3NzRXZhbChcbiAgICAgICAgcGFyZW50RG9tRWxlbWVudCxcbiAgICAgICAgJ2Rpc3BsYXknLFxuICAgICAgKTtcbiAgICAgIGltcG9ydGFudEZpZWxkc1snc2VsZWN0ZWRQYXJlbnRGbGV4RGlyZWN0aW9uJ10gPSBjc3NFdmFsKFxuICAgICAgICBwYXJlbnREb21FbGVtZW50LFxuICAgICAgICAnZmxleC1kaXJlY3Rpb24nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBhaUNvbnRleHRTZWxlY3Rpb24gPSBnZXRNZW1vcnlTdG9yYWdlSXRlbSgnYWlDb250ZXh0Jyk7XG5cbiAgICAvLyBEb24ndCBlbmFibGUgZHJhZ2dpbmcgaWYgdGhlIEFJIGNvbnRleHQgaXMgZW5hYmxlZFxuICAgIGlmICghYWlDb250ZXh0U2VsZWN0aW9uKSB7XG4gICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbSgnbW91c2VEcmFnQ29udGV4dCcsIGltcG9ydGFudEZpZWxkcyk7XG4gICAgfVxuXG4gICAgdXBkYXRlT3V0bGluZXMocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgfTtcblxuICBjb25zdCBvblBvaW50ZXJVcCA9IChlOiBhbnksIHBhcmVudFBvcnQ6IGFueSwgc3Rvcnlib2FyZElkOiBzdHJpbmcpID0+IHtcbiAgICBwYXNzVGhyb3VnaEV2ZW50c0lmTmVlZGVkKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG5cbiAgICBjb25zdCBtb3VzZURyYWdEYXRhID0gZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oJ21vdXNlRHJhZ0NvbnRleHQnKTtcblxuICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKCdtb3VzZURyYWdDb250ZXh0JywgbnVsbCk7XG5cbiAgICBpZiAobW91c2VEcmFnRGF0YT8uZHJhZ2dpbmcpIHtcbiAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpZDogRklYRURfSUZSQU1FX01FU1NBR0VfSURTLkRSQUdfRU5EX0VWRU5ULFxuICAgICAgICBldmVudDoge30sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGVPdXRsaW5lcyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICB9O1xuXG4gIGNvbnN0IG9uU2VsZWN0RWxlbWVudCA9IChcbiAgICBlOiBhbnksXG4gICAgcGFyZW50UG9ydDogYW55LFxuICAgIHN0b3J5Ym9hcmRJZDogc3RyaW5nLFxuICApOiBOYXZUcmVlTm9kZSB8IG51bGwgPT4ge1xuICAgIGNvbnN0IGRyaXZlTW9kZUVuYWJsZWQgPSAhIWdldFNlc3Npb25TdG9yYWdlSXRlbShcbiAgICAgICdkcml2ZU1vZGVFbmFibGVkJyxcbiAgICAgIHN0b3J5Ym9hcmRJZCxcbiAgICApO1xuXG4gICAgaWYgKGRyaXZlTW9kZUVuYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRLZXlUb05hdk5vZGUgPVxuICAgICAgZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oRUxFTUVOVF9LRVlfVE9fTkFWX05PREUpIHx8IHt9O1xuXG4gICAgbGV0IHNlbGVjdGVkTmF2Tm9kZTogTmF2VHJlZU5vZGUgfCBudWxsIHwgc3RyaW5nO1xuICAgIGlmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5KSB7XG4gICAgICBjb25zdCBlbGVtZW50S2V5OiBhbnkgPSBnZXRFbGVtZW50S2V5RnJvbU5vZGUoZS50YXJnZXQpO1xuICAgICAgc2VsZWN0ZWROYXZOb2RlID0gZWxlbWVudEtleVRvTmF2Tm9kZVtlbGVtZW50S2V5XTtcblxuICAgICAgLy8gU3BlY2lhbCBjYXNlIC0+IHRoaXMgaXMgdGhlIHRvcC1tb3N0IG5vZGUgc28gaXQgc2hvdWxkIHRyaWdnZXIgYSBzZWxlY3Qgb24gdGhlIHN0b3J5Ym9hcmRcbiAgICAgIGlmICghc2VsZWN0ZWROYXZOb2RlICYmIGUudGFyZ2V0LnBhcmVudE5vZGUgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgc2VsZWN0ZWROYXZOb2RlID0gU0VMRUNUX09SX0hPVkVSX1NUT1JZQk9BUkQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkTmF2Tm9kZSA9IGdldFNlbGVjdGFibGVOYXZOb2RlKGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRTZWxlY3RlZEVsZW1lbnRLZXkgPVxuICAgICAgZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oU0VMRUNURURfRUxFTUVOVF9LRVkpO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBub3QgYSB2YWxpZCBuYXYgbm9kZSwgaXQncyBub3Qgc29tZXRoaW5nIHdlIHRyYWNrIC0gZGVzZWxlY3QgYWxsXG4gICAgaWYgKCFzZWxlY3RlZE5hdk5vZGUpIHtcbiAgICAgIGlmIChjdXJyZW50U2VsZWN0ZWRFbGVtZW50S2V5KSB7XG4gICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuU0VMRUNURURfRUxFTUVOVF9LRVksXG4gICAgICAgICAgZWxlbWVudEtleTogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKFNFTEVDVEVEX0VMRU1FTlRfS0VZLCBudWxsKTtcblxuICAgICAgICB1cGRhdGVPdXRsaW5lcyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50U2VsZWN0ZWRFbGVtZW50ID0gVGVtcG9FbGVtZW50LmZyb21LZXkoXG4gICAgICBjdXJyZW50U2VsZWN0ZWRFbGVtZW50S2V5LFxuICAgICk7XG4gICAgY29uc3QgY3VycmVudE11bHRpU2VsZWN0ZWRLZXlzOiBzdHJpbmdbXSA9XG4gICAgICBnZXRNZW1vcnlTdG9yYWdlSXRlbShNVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMpIHx8IFtdO1xuXG4gICAgbGV0IG5ld1NlbGVjdGVkRWxlbWVudCA9XG4gICAgICB0eXBlb2Ygc2VsZWN0ZWROYXZOb2RlID09PSAnc3RyaW5nJ1xuICAgICAgICA/IFRlbXBvRWxlbWVudC5mb3JTdG9yeWJvYXJkKHN0b3J5Ym9hcmRJZClcbiAgICAgICAgOiBzZWxlY3RlZE5hdk5vZGUudGVtcG9FbGVtZW50O1xuICAgIGxldCBuZXdNdWx0aVNlbGVjdEtleXM6IHN0cmluZ1tdID0gW107XG5cbiAgICAvLyBJZiB0aGUgdXNlciBpcyBob2xkaW5nIHNoaWZ0LCBjaGVjayBpZiB3ZSBjYW4gbXVsdGktc2VsZWN0IChzb21ldGhpbmcgaGFzIHRvIGJlIGFscmVhZHkgc2VsZWN0ZWQpXG4gICAgLy8gTm90ZTogdGhpcyBsb2dpYyBnZW5lcmFsbHkgbWF0Y2hlcyB0aGUgbG9naWMgaW4gdGhlIGlmcmFtZSBzbGljZSBvbiB0ZW1wby13ZWJcbiAgICBpZiAoZS5zaGlmdEtleSAmJiBjdXJyZW50U2VsZWN0ZWRFbGVtZW50S2V5KSB7XG4gICAgICAvLyBGaXJzdCBjaGVjayBpZiB3ZSBhcmUgZGVzZWxlY3RpbmdcbiAgICAgIGNvbnN0IGVsZW1lbnRUb0Rlc2VsZWN0ID0gY3VycmVudE11bHRpU2VsZWN0ZWRLZXlzXG4gICAgICAgIC5tYXAoKGVsZW1lbnRLZXk6IHN0cmluZykgPT4gVGVtcG9FbGVtZW50LmZyb21LZXkoZWxlbWVudEtleSkpXG4gICAgICAgIC5maW5kKChlbGVtZW50OiBUZW1wb0VsZW1lbnQpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZWxlbWVudC5pc1BhcmVudE9mKG5ld1NlbGVjdGVkRWxlbWVudCkgfHxcbiAgICAgICAgICAgIGVsZW1lbnQuaXNFcXVhbChuZXdTZWxlY3RlZEVsZW1lbnQpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIGlmIChlbGVtZW50VG9EZXNlbGVjdCkge1xuICAgICAgICBuZXdNdWx0aVNlbGVjdEtleXMgPSBjdXJyZW50TXVsdGlTZWxlY3RlZEtleXMuZmlsdGVyKFxuICAgICAgICAgIChlbGVtZW50S2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50S2V5ICE9PSBlbGVtZW50VG9EZXNlbGVjdC5nZXRLZXkoKTtcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFBpY2sgYSBuZXcgZWxlbWVudCB0byBiZSB0aGUgbWFpbiBzZWxlY3RlZCBlbGVtZW50XG4gICAgICAgIC8vIE5vdGUsIGlmIHRoZSBsZW5ndGggaXMgMSwgdGhlcmUgaXMgbG9naWMgZnVydGhlciBkb3duIHRvIGhhbmRsZSB0aGF0IGNhc2UgZXhwbGljaXRseSAodG8gZXhpdCBtdWx0aXNlbGVjdCBtb2RlKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgZWxlbWVudFRvRGVzZWxlY3QuaXNFcXVhbChjdXJyZW50U2VsZWN0ZWRFbGVtZW50KSAmJlxuICAgICAgICAgIG5ld011bHRpU2VsZWN0S2V5cy5sZW5ndGggPiAxXG4gICAgICAgICkge1xuICAgICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQ6IEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5TRUxFQ1RFRF9FTEVNRU5UX0tFWSxcbiAgICAgICAgICAgIGVsZW1lbnRLZXk6IG5ld011bHRpU2VsZWN0S2V5c1swXSxcbiAgICAgICAgICAgIG91dGVySFRNTDogZ2V0RnVsbEh0bWxXaXRoRWxlbWVudChbbmV3TXVsdGlTZWxlY3RLZXlzWzBdXSksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0TWVtb3J5U3RvcmFnZUl0ZW0oU0VMRUNURURfRUxFTUVOVF9LRVksIG5ld011bHRpU2VsZWN0S2V5c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgY2FuIGFkZCB0aGlzIGVsZW1lbnRcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudFNlbGVjdGVkRWxlbWVudC5pc1NpYmxpbmdPZihuZXdTZWxlY3RlZEVsZW1lbnQpKSB7XG4gICAgICAgIGlmIChjdXJyZW50TXVsdGlTZWxlY3RlZEtleXM/Lmxlbmd0aCkge1xuICAgICAgICAgIG5ld011bHRpU2VsZWN0S2V5cyA9IGN1cnJlbnRNdWx0aVNlbGVjdGVkS2V5cy5jb25jYXQoW1xuICAgICAgICAgICAgbmV3U2VsZWN0ZWRFbGVtZW50LmdldEtleSgpLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld011bHRpU2VsZWN0S2V5cyA9IFtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RlZEVsZW1lbnRLZXksXG4gICAgICAgICAgICBuZXdTZWxlY3RlZEVsZW1lbnQuZ2V0S2V5KCksXG4gICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBjYXNlIHRoZSB1c2VyIGlzIHRyeWluZyB0byBtdWx0aXNlbGVjdCBidXQgaXQncyBub3Qgc29tZXRoaW5nIHRoYXQncyBhbGxvd2VkLCBqdXN0IHJldHVybiBidXQgZG9uJ3QgbWFrZSBhbnkgY2hhbmdlc1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbiBtdWx0aXNlbGVjdCBtb2RlLCBzZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICBpZiAobmV3TXVsdGlTZWxlY3RLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpZDogRklYRURfSUZSQU1FX01FU1NBR0VfSURTLk1VTFRJX1NFTEVDVEVEX0VMRU1FTlRfS0VZUyxcbiAgICAgICAgZWxlbWVudEtleXM6IG5ld011bHRpU2VsZWN0S2V5cyxcbiAgICAgICAgb3V0ZXJIVE1MczogZ2V0RnVsbEh0bWxXaXRoRWxlbWVudChuZXdNdWx0aVNlbGVjdEtleXMpLFxuICAgICAgfSk7XG4gICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbShNVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMsIG5ld011bHRpU2VsZWN0S2V5cyk7XG4gICAgICB1cGRhdGVPdXRsaW5lcyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuXG4gICAgICB0ZWFyZG93bkVkaXRhYmxlVGV4dChwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgcmV0dXJuIG51bGw7IC8vIENhbm5vdCBwZXJmb3JtIHJlZ3VsYXIgYWN0aW9ucyBvbiBhbnkgcGFydGljdWxhciBub2RlXG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIC0gbXVsdGlzZWxlY3RpbmcgYnV0IGRlc2VsZWN0aW5nIGRvd24gdG8gMSwgc3RvcCB0aGUgbXVsdGlzZWxlY3QgbW9kZVxuICAgIGlmIChuZXdNdWx0aVNlbGVjdEtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBuZXdTZWxlY3RlZEVsZW1lbnQgPSBUZW1wb0VsZW1lbnQuZnJvbUtleShuZXdNdWx0aVNlbGVjdEtleXNbMF0pO1xuICAgIH1cblxuICAgIGNvbnN0IGNsZWFyTXVsdGlTZWxlY3RTdGF0ZSA9ICgpID0+IHtcbiAgICAgIC8vIE5vdCBtdWx0aS1zZWxlY3RpbmcsIHNvIGNsZWFyIHRoZSBtdWx0aXNlbGVjdCBzdGF0ZVxuICAgICAgLy8gV2FudCB0byBkbyB0aGlzIGFmdGVyIHNldHRpbmcgdGhlIHNlbGVjdGVkIGVsZW1lbnQgdG8gcHJldmVudCBmbGFzaGluZ1xuICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTLFxuICAgICAgICBlbGVtZW50S2V5czogW10sXG4gICAgICAgIG91dGVySFRNTHM6IFtdLFxuICAgICAgfSk7XG4gICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbShNVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMsIG51bGwpO1xuICAgIH07XG5cbiAgICAvLyBTZWxlY3RpbmcgdGhlIHN0b3J5Ym9hcmQgZnJvbSB3aXRoaW5cbiAgICBpZiAobmV3U2VsZWN0ZWRFbGVtZW50LmlzU3Rvcnlib2FyZCgpKSB7XG4gICAgICBpZiAobmV3U2VsZWN0ZWRFbGVtZW50LmdldEtleSgpICE9PSBjdXJyZW50U2VsZWN0ZWRFbGVtZW50S2V5KSB7XG4gICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuU0VMRUNURURfRUxFTUVOVF9LRVksXG4gICAgICAgICAgZWxlbWVudEtleTogbmV3U2VsZWN0ZWRFbGVtZW50LmdldEtleSgpLFxuICAgICAgICAgIG91dGVySFRNTDogZ2V0RnVsbEh0bWxXaXRoRWxlbWVudChbbmV3U2VsZWN0ZWRFbGVtZW50LmdldEtleSgpXSksXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbShTRUxFQ1RFRF9FTEVNRU5UX0tFWSwgbmV3U2VsZWN0ZWRFbGVtZW50LmdldEtleSgpKTtcblxuICAgICAgICB1cGRhdGVPdXRsaW5lcyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgfVxuXG4gICAgICB0ZWFyZG93bkVkaXRhYmxlVGV4dChwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgY2xlYXJNdWx0aVNlbGVjdFN0YXRlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudGx5RWRpdGluZygpKSB7XG4gICAgICBjb25zdCBlZGl0aW5nSW5mbyA9IGdldEVkaXRpbmdJbmZvKCk7XG5cbiAgICAgIGlmIChlZGl0aW5nSW5mbz8ua2V5ICE9PSBjdXJyZW50U2VsZWN0ZWRFbGVtZW50S2V5KSB7XG4gICAgICAgIHRlYXJkb3duRWRpdGFibGVUZXh0KHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICB9XG5cbiAgICAgIGNsZWFyTXVsdGlTZWxlY3RTdGF0ZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBpZiAoXG4gICAgICBjYW5FZGl0VGV4dChuZXdTZWxlY3RlZEVsZW1lbnQpICYmXG4gICAgICBuZXdTZWxlY3RlZEVsZW1lbnQuZ2V0S2V5KCkgPT09IGN1cnJlbnRTZWxlY3RlZEVsZW1lbnRLZXlcbiAgICApIHtcbiAgICAgIHNldHVwRWRpdGFibGVUZXh0KG5ld1NlbGVjdGVkRWxlbWVudCwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICB9XG5cbiAgICBpZiAobmV3U2VsZWN0ZWRFbGVtZW50LmdldEtleSgpID09PSBjdXJyZW50U2VsZWN0ZWRFbGVtZW50S2V5KSB7XG4gICAgICBjbGVhck11bHRpU2VsZWN0U3RhdGUoKTtcbiAgICAgIHJldHVybiBzZWxlY3RlZE5hdk5vZGUgYXMgTmF2VHJlZU5vZGU7XG4gICAgfVxuXG4gICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICBpZDogRklYRURfSUZSQU1FX01FU1NBR0VfSURTLlNFTEVDVEVEX0VMRU1FTlRfS0VZLFxuICAgICAgZWxlbWVudEtleTogbmV3U2VsZWN0ZWRFbGVtZW50LmdldEtleSgpLFxuICAgICAgb3V0ZXJIVE1MOiBnZXRGdWxsSHRtbFdpdGhFbGVtZW50KFtuZXdTZWxlY3RlZEVsZW1lbnQuZ2V0S2V5KCldKSxcbiAgICB9KTtcbiAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbShTRUxFQ1RFRF9FTEVNRU5UX0tFWSwgbmV3U2VsZWN0ZWRFbGVtZW50LmdldEtleSgpKTtcbiAgICB1cGRhdGVPdXRsaW5lcyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgIGNsZWFyTXVsdGlTZWxlY3RTdGF0ZSgpO1xuICAgIHJldHVybiBzZWxlY3RlZE5hdk5vZGUgYXMgTmF2VHJlZU5vZGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgZXZlbnRzIHdlcmUgcGFzc2VkIHRocm91Z2hcbiAgICovXG4gIGNvbnN0IHBhc3NUaHJvdWdoRXZlbnRzSWZOZWVkZWQgPSAoXG4gICAgZTogYW55LFxuICAgIHBhcmVudFBvcnQ6IGFueSxcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZyxcbiAgKTogYm9vbGVhbiA9PiB7XG4gICAgY29uc3QgZHJpdmVNb2RlRW5hYmxlZCA9ICEhZ2V0U2Vzc2lvblN0b3JhZ2VJdGVtKFxuICAgICAgJ2RyaXZlTW9kZUVuYWJsZWQnLFxuICAgICAgc3Rvcnlib2FyZElkLFxuICAgICk7XG4gICAgY29uc3QgZWRpdGluZ1RleHRJbmZvID0gZ2V0RWRpdGluZ0luZm8oKTtcblxuICAgIGlmIChkcml2ZU1vZGVFbmFibGVkIHx8IGVkaXRpbmdUZXh0SW5mbykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZT8ucHJldmVudERlZmF1bHQ/LigpO1xuICAgIGU/LnN0b3BQcm9wYWdhdGlvbj8uKCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIGNvbnN0IG9uQ2xpY2tFbGVtZW50Q29udGV4dE1lbnUgPSAoXG4gICAgZTogYW55LFxuICAgIHBhcmVudFBvcnQ6IGFueSxcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZyxcbiAgKSA9PiB7XG4gICAgY29uc3QgcGFzc2VkVGhyb3VnaCA9IHBhc3NUaHJvdWdoRXZlbnRzSWZOZWVkZWQoXG4gICAgICBlLFxuICAgICAgcGFyZW50UG9ydCxcbiAgICAgIHN0b3J5Ym9hcmRJZCxcbiAgICApO1xuICAgIGlmIChwYXNzZWRUaHJvdWdoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAvLyBNb3VzZSBkb3duIGlzIGNhbGxlZCB3aGVuIGEgdXNlciBjbGlja3MgdGhlIGNvbnRleHQgbWVudSwgYnV0IG5vdCBtb3VzZSB1cCwgc28gY2xlYXIgdGhlIG1vdXNlIGRvd25cbiAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbSgnbW91c2VEcmFnQ29udGV4dCcsIG51bGwpO1xuXG4gICAgY29uc3QgZWxlbWVudEtleVRvTmF2Tm9kZSA9XG4gICAgICBnZXRNZW1vcnlTdG9yYWdlSXRlbShFTEVNRU5UX0tFWV9UT19OQVZfTk9ERSkgfHwge307XG5cbiAgICBsZXQgcmVxdWVzdGVkTmF2Tm9kZTogTmF2VHJlZU5vZGUgfCBudWxsIHwgc3RyaW5nO1xuICAgIGlmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5KSB7XG4gICAgICBjb25zdCBlbGVtZW50S2V5OiBhbnkgPSBnZXRFbGVtZW50S2V5RnJvbU5vZGUoZS50YXJnZXQpO1xuICAgICAgcmVxdWVzdGVkTmF2Tm9kZSA9IGVsZW1lbnRLZXlUb05hdk5vZGVbZWxlbWVudEtleV07XG5cbiAgICAgIC8vIFNwZWNpYWwgY2FzZSAtPiB0aGlzIGlzIHRoZSB0b3AtbW9zdCBub2RlIHNvIGl0IHNob3VsZCB0cmlnZ2VyIGEgY29udGV4dCBtZW51IG9uIHRoZSBzdG9yeWJvYXJkXG4gICAgICBpZiAoIXJlcXVlc3RlZE5hdk5vZGUgJiYgZS50YXJnZXQucGFyZW50Tm9kZSA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICByZXF1ZXN0ZWROYXZOb2RlID0gU0VMRUNUX09SX0hPVkVSX1NUT1JZQk9BUkQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3RlZE5hdk5vZGUgPSBnZXRTZWxlY3RhYmxlTmF2Tm9kZShlKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50U2VsZWN0ZWRFbGVtZW50S2V5ID1cbiAgICAgIGdldE1lbW9yeVN0b3JhZ2VJdGVtKFNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcbiAgICBjb25zdCBjdXJyZW50TXVsdGlTZWxlY3RlZEtleXMgPSBnZXRNZW1vcnlTdG9yYWdlSXRlbShcbiAgICAgIE1VTFRJX1NFTEVDVEVEX0VMRU1FTlRfS0VZUyxcbiAgICApO1xuXG4gICAgaWYgKCFyZXF1ZXN0ZWROYXZOb2RlIHx8IHR5cGVvZiByZXF1ZXN0ZWROYXZOb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKFxuICAgICAgICByZXF1ZXN0ZWROYXZOb2RlID09PSBTRUxFQ1RfT1JfSE9WRVJfU1RPUllCT0FSRCAmJlxuICAgICAgICAhY3VycmVudE11bHRpU2VsZWN0ZWRLZXlzPy5sZW5ndGhcbiAgICAgICkge1xuICAgICAgICBjb25zdCBzdG9yeWJvYXJkS2V5ID0gVGVtcG9FbGVtZW50LmZvclN0b3J5Ym9hcmQoc3Rvcnlib2FyZElkKS5nZXRLZXkoKTtcblxuICAgICAgICBpZiAoY3VycmVudFNlbGVjdGVkRWxlbWVudEtleSA9PT0gc3Rvcnlib2FyZEtleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuU0VMRUNURURfRUxFTUVOVF9LRVksXG4gICAgICAgICAgZWxlbWVudEtleTogc3Rvcnlib2FyZEtleSxcbiAgICAgICAgfSk7XG4gICAgICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKFNFTEVDVEVEX0VMRU1FTlRfS0VZLCBzdG9yeWJvYXJkS2V5KTtcblxuICAgICAgICB1cGRhdGVPdXRsaW5lcyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjb250ZXh0UmVxdWVzdGVkRWxlbWVudEtleTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnRLZXkgPSBnZXRNZW1vcnlTdG9yYWdlSXRlbShTRUxFQ1RFRF9FTEVNRU5UX0tFWSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gVGVtcG9FbGVtZW50LmZyb21LZXkoc2VsZWN0ZWRFbGVtZW50S2V5KTtcblxuICAgIC8vIERvbid0IHNlbGVjdCBhbnkgY2hpbGRyZW4gYXMgdGhlIHVzZXIgbWlnaHQgYmUgcmlnaHQgY2xpY2tpbmcgYSBub2RlIHRoZXkgc2VsZWN0ZWRcbiAgICBpZiAoXG4gICAgICAhcmVxdWVzdGVkTmF2Tm9kZS50ZW1wb0VsZW1lbnQuaXNFcXVhbChzZWxlY3RlZEVsZW1lbnQpICYmXG4gICAgICAhc2VsZWN0ZWRFbGVtZW50LmlzUGFyZW50T2YocmVxdWVzdGVkTmF2Tm9kZS50ZW1wb0VsZW1lbnQpICYmXG4gICAgICAhY3VycmVudE11bHRpU2VsZWN0ZWRLZXlzPy5sZW5ndGggLy8gQWxzbyBkb24ndCBzZWxlY3QgYW55dGhpbmcgbmV3IGlmIGluIG11bHRpc2VsZWN0IG1vZGVcbiAgICApIHtcbiAgICAgIGNvbnRleHRSZXF1ZXN0ZWRFbGVtZW50S2V5ID0gcmVxdWVzdGVkTmF2Tm9kZS50ZW1wb0VsZW1lbnQuZ2V0S2V5KCk7XG5cbiAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpZDogRklYRURfSUZSQU1FX01FU1NBR0VfSURTLlNFTEVDVEVEX0VMRU1FTlRfS0VZLFxuICAgICAgICBlbGVtZW50S2V5OiBjb250ZXh0UmVxdWVzdGVkRWxlbWVudEtleSxcbiAgICAgICAgb3V0ZXJIVE1MOiBnZXRGdWxsSHRtbFdpdGhFbGVtZW50KFtjb250ZXh0UmVxdWVzdGVkRWxlbWVudEtleV0pLFxuICAgICAgfSk7XG4gICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbShTRUxFQ1RFRF9FTEVNRU5UX0tFWSwgY29udGV4dFJlcXVlc3RlZEVsZW1lbnRLZXkpO1xuICAgICAgdXBkYXRlT3V0bGluZXMocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbXBvcnRhbnRGaWVsZHMgPSB7XG4gICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBlLmNsaWVudFksXG4gICAgfTtcblxuICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgaWQ6IEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5DT05URVhUX1JFUVVFU1RFRCxcbiAgICAgIGV2ZW50OiBpbXBvcnRhbnRGaWVsZHMsXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgYnVpbGRBbmRTZW5kTmF2VHJlZSA9IGFzeW5jIChcbiAgICBwYXJlbnRQb3J0OiBhbnksXG4gICAgc3Rvcnlib2FyZElkOiBzdHJpbmcsXG4gICAgdHJlZUVsZW1lbnRMb29rdXA/OiBhbnksXG4gICAgc2NvcGVMb29rdXA/OiBhbnksXG4gICAgc3Rvcnlib2FyZENvbXBvbmVudEVsZW1lbnQ/OiBhbnksXG4gICkgPT4ge1xuICAgIGxldCB0cmVlRWxlbWVudHMgPSB0cmVlRWxlbWVudExvb2t1cDtcbiAgICBpZiAoIXRyZWVFbGVtZW50cykge1xuICAgICAgdHJlZUVsZW1lbnRzID0gZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oVFJFRV9FTEVNRU5UX0xPT0tVUCkgfHwge307XG4gICAgfVxuXG4gICAgbGV0IHNjb3BlcyA9IHNjb3BlTG9va3VwO1xuICAgIGlmICghc2NvcGVzKSB7XG4gICAgICBzY29wZXMgPSBnZXRNZW1vcnlTdG9yYWdlSXRlbShTQ09QRV9MT09LVVApIHx8IHt9O1xuICAgIH1cblxuICAgIGxldCBzdG9yeWJvYXJkQ29tcG9uZW50ID0gc3Rvcnlib2FyZENvbXBvbmVudEVsZW1lbnQ7XG4gICAgaWYgKHN0b3J5Ym9hcmRDb21wb25lbnRFbGVtZW50ID09PSAnRVhQTElDSVRfTk9ORScpIHtcbiAgICAgIHN0b3J5Ym9hcmRDb21wb25lbnQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoIXN0b3J5Ym9hcmRDb21wb25lbnQpIHtcbiAgICAgIHN0b3J5Ym9hcmRDb21wb25lbnQgPSBnZXRNZW1vcnlTdG9yYWdlSXRlbShTVE9SWUJPQVJEX0NPTVBPTkVOVCkgfHwge307XG4gICAgfVxuXG4gICAgY29uc3Qga25vd25Db21wb25lbnROYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGtub3duQ29tcG9uZW50SW5zdGFuY2VOYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgaWYgKHRyZWVFbGVtZW50cykge1xuICAgICAgT2JqZWN0LnZhbHVlcyh0cmVlRWxlbWVudHMpLmZvckVhY2goKHRyZWVFbGVtZW50OiBhbnkpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRyZWVFbGVtZW50LnR5cGUgPT09ICdjb21wb25lbnQnIHx8XG4gICAgICAgICAgdHJlZUVsZW1lbnQudHlwZSA9PT0gJ3N0b3J5Ym9vay1jb21wb25lbnQnXG4gICAgICAgICkge1xuICAgICAgICAgIGtub3duQ29tcG9uZW50TmFtZXMuYWRkKHRyZWVFbGVtZW50LmNvbXBvbmVudE5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyZWVFbGVtZW50LnR5cGUgPT09ICdjb21wb25lbnQtaW5zdGFuY2UnKSB7XG4gICAgICAgICAga25vd25Db21wb25lbnRJbnN0YW5jZU5hbWVzLmFkZCh0cmVlRWxlbWVudC5jb21wb25lbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudEtleVRvTG9va3VwTGlzdCA9IHt9O1xuICAgIGNvbnN0IGVsZW1lbnRLZXlUb05hdk5vZGUgPSB7fTtcblxuICAgIGNvbnN0IGJ1aWx0TmF2VHJlZSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGJ1aWxkTmF2Rm9yTm9kZU5vbkJsb2NraW5nKFxuICAgICAgICB7XG4gICAgICAgICAgc3Rvcnlib2FyZElkLFxuICAgICAgICAgIHBhcmVudDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5vZGU6ICQoJ2JvZHknKS5nZXQoMCksXG4gICAgICAgICAgdW5pcXVlUGF0aEJhc2U6ICcnLFxuICAgICAgICAgIHVuaXF1ZVBhdGhBZGRvbjogJ3Jvb3QnLFxuICAgICAgICAgIHNjb3BlTG9va3VwOiBzY29wZXMsXG4gICAgICAgICAgdHJlZUVsZW1lbnRzLFxuICAgICAgICAgIGtub3duQ29tcG9uZW50TmFtZXMsXG4gICAgICAgICAga25vd25Db21wb25lbnRJbnN0YW5jZU5hbWVzLFxuICAgICAgICAgIGVsZW1lbnRLZXlUb0xvb2t1cExpc3QsXG4gICAgICAgICAgZWxlbWVudEtleVRvTmF2Tm9kZSxcbiAgICAgICAgICBkb21VbmlxdWVQYXRoOiAnMCcsXG4gICAgICAgIH0sXG4gICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pO1xuICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKEVMRU1FTlRfS0VZX1RPX0xPT0tVUF9MSVNULCBlbGVtZW50S2V5VG9Mb29rdXBMaXN0KTtcblxuICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKENVUlJFTlRfTkFWX1RSRUUsIGJ1aWx0TmF2VHJlZSk7XG5cbiAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbShFTEVNRU5UX0tFWV9UT19OQVZfTk9ERSwgZWxlbWVudEtleVRvTmF2Tm9kZSk7XG5cbiAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuTkFWX1RSRUUsXG4gICAgICBuYXZUcmVlOiBidWlsdE5hdlRyZWUsXG4gICAgICBvdXRlckh0bWw6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUwsXG4gICAgfSk7XG5cbiAgICAvLyBSdW4gY2FsbGJhY2tzXG4gICAgcnVuTmF2VHJlZUJ1aWx0Q2FsbGJhY2tzKCk7XG4gIH07XG5cbiAgY29uc3Qgb25GbHVzaFN0YXJ0ID0gKCkgPT4ge1xuICAgIC8vIEZpbmQgYWxsIGluc3RhbnQgdXBkYXRlIHN0eWxpbmcgY2xhc3NlcyB0byBkZWxldGVcbiAgICBjb25zdCBjbGFzc2VzVG9EZWxldGU6IHN0cmluZ1tdID0gW107XG4gICAgJChgKltjbGFzcyo9JHtURU1QT19JTlNUQU5UX1VQREFURV9TVFlMSU5HX1BSRUZJWH1dYCkuZWFjaCgoaSwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgY2xhc3NlcyA9IChlbGVtZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykuc3BsaXQoJyAnKTtcbiAgICAgIGNsYXNzZXMuZm9yRWFjaCgoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIGlmIChjbGFzc05hbWUuc3RhcnRzV2l0aChURU1QT19JTlNUQU5UX1VQREFURV9TVFlMSU5HX1BSRUZJWCkpIHtcbiAgICAgICAgICBjbGFzc2VzVG9EZWxldGUucHVzaChjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgICQoYCpbJHtURU1QT19ERUxFVEVfQUZURVJfUkVGUkVTSH09dHJ1ZV1gKS5hdHRyKFxuICAgICAgVEVNUE9fUVVFVUVfREVMRVRFX0FGVEVSX0hPVF9SRUxPQUQsXG4gICAgICAndHJ1ZScsXG4gICAgKTtcblxuICAgIC8vIENsZWFyIHRoZSBhZGQgY2xhc3MgaW5zdGFudCB1cGRhdGUgcXVldWUgYXMgdGhvc2UgaXRlbXMgd2lsbCBiZSBhcHBsaWVkIGluIHRoZSBob3QgcmVsb2FkXG4gICAgc2V0TWVtb3J5U3RvcmFnZUl0ZW0oQUREX0NMQVNTX0lOU1RBTlRfVVBEQVRFX1FVRVVFLCBbXSk7XG5cbiAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbSgnUE9TVF9IT1RfUkVMT0FEX0NMRUFSJywge1xuICAgICAgY2xhc3Nlc1RvRGVsZXRlLFxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IGNsZWFySW5zdGFudFVwZGF0ZXNBbmRTZW5kTmF2VHJlZSA9IGFzeW5jIChcbiAgICBwYXJlbnRQb3J0OiBhbnksXG4gICAgc3Rvcnlib2FyZElkOiBzdHJpbmcsXG4gICkgPT4ge1xuICAgIGdsb2JhbFVJVXBkYXRlUnVubmVyKCgpID0+IHtcbiAgICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKExBU1RfTkFWX1RSRUVfUkVGUkVTSF9USU1FLCBuZXcgRGF0ZSgpKTtcblxuICAgICAgY29uc3QgeyBjbGFzc2VzVG9EZWxldGUgfSA9XG4gICAgICAgIGdldE1lbW9yeVN0b3JhZ2VJdGVtKCdQT1NUX0hPVF9SRUxPQURfQ0xFQVInKSB8fCB7fTtcblxuICAgICAgLy8gRGVsZXRlIGFsbCBpbnN0YW50IHVwZGF0ZSBjaGFuZ2VkIGVsZW1lbnRzXG4gICAgICAkKGAqWyR7VEVNUE9fUVVFVUVfREVMRVRFX0FGVEVSX0hPVF9SRUxPQUR9PXRydWVdYCkucmVtb3ZlKCk7XG5cbiAgICAgIC8vIENsZWFyIHRoZSBhZGRlZCBkaXNwbGF5IG5vbmVzXG4gICAgICAkKGAuJHtURU1QT19ESVNQTEFZX05PTkVfVU5USUxfUkVGUkVTSF9DTEFTU31gKS5yZW1vdmVDbGFzcyhcbiAgICAgICAgVEVNUE9fRElTUExBWV9OT05FX1VOVElMX1JFRlJFU0hfQ0xBU1MsXG4gICAgICApO1xuICAgICAgJChgKlske1RFTVBPX0lOU1RBTlRfVVBEQVRFfT10cnVlXWApLnJlbW92ZUF0dHIoVEVNUE9fSU5TVEFOVF9VUERBVEUpO1xuICAgICAgJChgKlske1RFTVBPX0RPX05PVF9TSE9XX0lOX05BVl9VTlRJTF9SRUZSRVNIfT10cnVlXWApLnJlbW92ZUF0dHIoXG4gICAgICAgIFRFTVBPX0RPX05PVF9TSE9XX0lOX05BVl9VTlRJTF9SRUZSRVNILFxuICAgICAgKTtcblxuICAgICAgJChgLiR7VEVNUE9SQVJZX1NUWUxJTkdfQ0xBU1NfTkFNRX1gKS5yZW1vdmVDbGFzcyhcbiAgICAgICAgVEVNUE9SQVJZX1NUWUxJTkdfQ0xBU1NfTkFNRSxcbiAgICAgICk7XG5cbiAgICAgIC8vIEFueSBjbGFzc2VzIG1hcmtlZCB0byBkZWxldGUgYmVmb3JlIHRoZSBob3QgcmVsb2FkXG4gICAgICBjbGFzc2VzVG9EZWxldGU/LmZvckVhY2goKGNsczogc3RyaW5nKSA9PiB7XG4gICAgICAgICQoYC4ke2Nsc31gKS5yZW1vdmVDbGFzcyhjbHMpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG5ld0FkZENsYXNzUXVldWUgPVxuICAgICAgICBnZXRNZW1vcnlTdG9yYWdlSXRlbShBRERfQ0xBU1NfSU5TVEFOVF9VUERBVEVfUVVFVUUpIHx8IFtdO1xuXG4gICAgICAvLyBBbnkgYXR0cmlidXRlcyB0aGF0IHN0YXJ0IHdpdGggdGhlIHN0eWxpbmcgcHJlZml4IGxlZnRvdmVyIG1lYW4gdGhhdCB0aGUgY2xhc3MgbmVlZHMgdG8gYmUgcmUtYXBwbGllZFxuICAgICAgLy8gdGhlc2UgYXJlIGNsYXNzZXMgdGhhdCB3ZXJlIGFkZGVkIGluIGluc3RhbnQgdXBkYXRlcyB3aGlsZSB0aGUgaG90IHJlbG9hZCB3YXMgaW4gcHJvZ3Jlc3NcbiAgICAgIG5ld0FkZENsYXNzUXVldWUuZm9yRWFjaCgoaXRlbTogYW55KSA9PiB7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgY29kZWJhc2VJZCwgY2xhc3NOYW1lIH0gPSBpdGVtO1xuICAgICAgICBpZiAoY29kZWJhc2VJZCAmJiBjbGFzc05hbWUpIHtcbiAgICAgICAgICAkKGAuJHtjb2RlYmFzZUlkfWApLmF0dHIoVEVNUE9fSU5TVEFOVF9VUERBVEUsICd0cnVlJyk7XG5cbiAgICAgICAgICAkKGAuJHtjb2RlYmFzZUlkfWApLmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVidWlsZCB0aGUgbmF2IHRyZWUgb24gRE9NIGNoYW5nZWQgYWZ0ZXIgc29tZSB0aW1lIGhhcyBwYXNzZWRcbiAgICAvLyB0aGlzIGdpdmVzIHRoZSByZWFjdCBmaWJlciB0aW1lIHRvIGJlIGZ1bGx5IHJlY29uY2lsZWRcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2xlZXAoMzAwKTtcblxuICAgICAgZ2xvYmFsVUlVcGRhdGVSdW5uZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBidWlsZEFuZFNlbmROYXZUcmVlKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICAgIHVwZGF0ZU91dGxpbmVzKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFUlJPUjogQ291bGQgbm90IHJlLWNyZWF0ZSBuYXYgdHJlZSBvbiBET00gY2hhbmdlLCAnICsgZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uRE9NQ2hhbmdlZCA9ICh7XG4gICAgbXV0YXRpb25zLFxuICAgIHBhcmVudFBvcnQsXG4gICAgc3Rvcnlib2FyZElkLFxuICAgIGZyb21OZXh0SnNMb2FkZXIsXG4gIH06IHtcbiAgICBtdXRhdGlvbnM6IGFueVtdO1xuICAgIHBhcmVudFBvcnQ6IGFueTtcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZztcblxuICAgIC8vIElmIHNldCB0byB0cnVlIHRoaXMgaXMgY2FsbGVkIGZyb20gdGhlIHNoYWRvdyByb290IGZvciB0aGUgbmV4dGpzIGJ1aWxkIHdhdGNoZXIgKHRoZSBzcGlubmluZyB0cmlhbmdsZSlcbiAgICBmcm9tTmV4dEpzTG9hZGVyPzogYm9vbGVhbjtcbiAgfSkgPT4ge1xuICAgIC8vIFVkcGF0ZSB0aGUgaHJlZiBpbiB0aGUgcGFyZW50IGNvbnRhaW5lclxuICAgIGlmIChnZXRNZW1vcnlTdG9yYWdlSXRlbSgnaHJlZicpICE9PSB3aW5kb3cubG9jYXRpb24uaHJlZikge1xuICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuTEFURVNUX0hSRUYsXG4gICAgICAgIGhyZWY6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgfSk7XG4gICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbSgnaHJlZicsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgcmVmcmVzaCB0aGUgbmF2IHRyZWVcbiAgICBsZXQgcmVmcmVzaE5hdlRyZWUgPSBmYWxzZTtcbiAgICBpZiAoZnJvbU5leHRKc0xvYWRlcikge1xuICAgICAgLy8gRnJvbSB0aGUgbmV4dGpzIGxvYWRlciwgcmVmcmVzaCB3aGVuIHRoZSBsb2FkZXIgZ2V0cyBoaWRkZW4gKG1lYW5zIHJlZnJlc2ggaXMgZG9uZSlcbiAgICAgIGNvbnN0IG11dGF0aW9uVGFyZ2V0ID0gbXV0YXRpb25zPy5bMF0/LnRhcmdldDtcbiAgICAgIGlmIChtdXRhdGlvblRhcmdldCAmJiBtdXRhdGlvblRhcmdldC5pZCA9PT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgICAgY29uc3QgY3VycmVudGx5SG90UmVsb2FkaW5nID0gZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oSE9UX1JFTE9BRElORyk7XG5cbiAgICAgICAgaWYgKG11dGF0aW9uVGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndmlzaWJsZScpKSB7XG4gICAgICAgICAgc2V0TWVtb3J5U3RvcmFnZUl0ZW0oSE9UX1JFTE9BRElORywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TWVtb3J5U3RvcmFnZUl0ZW0oSE9UX1JFTE9BRElORywgZmFsc2UpO1xuICAgICAgICAgIHJlZnJlc2hOYXZUcmVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtdXRhdGlvbnMuZm9yRWFjaCgoZTogYW55KSA9PiB7XG4gICAgICAgIGlmIChyZWZyZXNoTmF2VHJlZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBjbGFzcyBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQgb24gYW4gZWxlbWVudCB3ZSBoYXZlIHRvIHJlcGFyc2UgdGhlIG5hdiB0cmVlIHRvIGFkZCB0aGUgZWxlbWVudCBrZXlcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGUudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmXG4gICAgICAgICAgZS5hdHRyaWJ1dGVOYW1lID09PSAnY2xhc3MnICYmXG4gICAgICAgICAgZS50YXJnZXQgJiZcbiAgICAgICAgICAhaXNOb2RlT3V0bGluZShlLnRhcmdldCkgJiZcbiAgICAgICAgICAhaXNNb3ZpbmdFbGVtZW50KGUudGFyZ2V0KSAmJlxuICAgICAgICAgIC8vIEFuZCBub3QgYSBzY3JpcHRcbiAgICAgICAgICAvLyBCdWcgZm91bmQgb24gT2N0IDgsIDIwMjQsIGZvciBzb21lIHJlYXNvbiB0aGUgc2NyaXB0IGtlcHQgdHJpZ2dlcmluZyBhIHJlbG9hZFxuICAgICAgICAgICFlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3NjcmlwdCcpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIEFuIGVsZW1lbnQgd2hpY2ggZG9lc24ndCBoYXZlIGFuIGVsZW1lbnQga2V5IGhhcyBjaGFuZ2VkXG4gICAgICAgICAgaWYgKCFpc0VsZW1lbnRJblN2ZyhlLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJlZnJlc2hOYXZUcmVlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBbZS5hZGRlZE5vZGVzLCBlLnJlbW92ZWROb2Rlc10uZm9yRWFjaCgobm9kZUxpc3QpID0+IHtcbiAgICAgICAgICBpZiAocmVmcmVzaE5hdlRyZWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW5vZGVMaXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZUxpc3QuZm9yRWFjaCgobm9kZTogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzTm9kZU91dGxpbmUobm9kZSkgJiYgIWlzTW92aW5nRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgICByZWZyZXNoTmF2VHJlZSA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZnJlc2hOYXZUcmVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW4gdGhlc2UgY2FzZXMgd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGEgbmF2IHRyZWUgcmVmcmVzaCByaWdodCBhd2F5XG4gICAgLy8gc2luY2UgdGhlIGhvdCByZWxvYWQgbWF5IG5vdCBoYXZlIGhhcHBlbmVkIHlldC4gU28gd2Ugc2V0IGEgdGltZW91dCBhbmQgb25seVxuICAgIC8vIHRyaWdnZXIgYSBuYXYgdHJlZSByZWZyZXNoIGlmIGFub3RoZXIgb25lIGhhc24ndCBoYXBwZW5lZCBpbiBiZXR3ZWVuXG4gICAgaWYgKGZyb21OZXh0SnNMb2FkZXIpIHtcbiAgICAgIGNvbnN0IHRyaWdnZXJUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBsYXN0UmVmcmVzaFRpbWUgPSBnZXRNZW1vcnlTdG9yYWdlSXRlbShcbiAgICAgICAgICBMQVNUX05BVl9UUkVFX1JFRlJFU0hfVElNRSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBEb24ndCByZS1jbGVhciBhbmQgc2VuZCBpZiBhbm90aGVyIHJlZnJlc2ggaGFzIGhhcHBlbmVkIGluIHRoZSBtZWFudGltZVxuICAgICAgICBpZiAoIWxhc3RSZWZyZXNoVGltZSB8fCBsYXN0UmVmcmVzaFRpbWUgPCB0cmlnZ2VyVGltZSkge1xuICAgICAgICAgIGNsZWFySW5zdGFudFVwZGF0ZXNBbmRTZW5kTmF2VHJlZShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjbGVhckluc3RhbnRVcGRhdGVzQW5kU2VuZE5hdlRyZWUocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgfTtcblxuICBjb25zdCBvbldoZWVsID0gKGU6IGFueSwgcGFyZW50UG9ydDogYW55LCBzdG9yeWJvYXJkSWQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHBhc3NlZFRocm91Z2ggPSBwYXNzVGhyb3VnaEV2ZW50c0lmTmVlZGVkKFxuICAgICAgZSxcbiAgICAgIHBhcmVudFBvcnQsXG4gICAgICBzdG9yeWJvYXJkSWQsXG4gICAgKTtcblxuICAgIGNvbnN0IGlzU2Nyb2xsU2hvcnRjdXQgPSBlLmFsdEtleTtcbiAgICBjb25zdCBpc1pvb21TaG9ydGN1dCA9IGUuY3RybEtleSB8fCBlLm1ldGFLZXk7XG5cbiAgICAvLyBJZiB0aGUgdXNlciB3YW50cyB0byBzY3JvbGwgKGVpdGhlciBieSBiZWluZyBpbiBkcml2ZSBtb2RlLCBvciBieSBob2xkaW5nIGFsdClcbiAgICAvLyBhbmQgdGhleSBhcmVuJ3QgdHJ5aW5nIHRvIHpvb20sIGZhbGxiYWNrIHRvIGRlZmF1bHQgYmVoYXZpb3VyLlxuICAgIGlmICghaXNab29tU2hvcnRjdXQgJiYgKHBhc3NlZFRocm91Z2ggfHwgaXNTY3JvbGxTaG9ydGN1dCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGNvbnN0IGltcG9ydGFudEZpZWxkcyA9IHtcbiAgICAgIGRlbHRhWDogZS5kZWx0YVgsXG4gICAgICBkZWx0YVk6IGUuZGVsdGFZLFxuICAgICAgd2hlZWxEZWx0YTogZS53aGVlbERlbHRhLFxuICAgICAgeDogZS54LFxuICAgICAgeTogZS55LFxuICAgICAgYWx0S2V5OiBlLmFsdEtleSxcbiAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxuICAgIH07XG5cbiAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuV0hFRUxfRVZFTlQsXG4gICAgICBldmVudDogaW1wb3J0YW50RmllbGRzLFxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnRNZXRhZGF0YSA9ICgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBsZXQgdGFnTmFtZSwgaXNDb250ZW50RWRpdGFibGUsIGVsZW1lbnRUeXBlO1xuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHRhZ05hbWUgPSBhY3RpdmVFbGVtZW50LnRhZ05hbWU7XG5cbiAgICAgIGlmIChhY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgaXNDb250ZW50RWRpdGFibGUgPSBhY3RpdmVFbGVtZW50LmlzQ29udGVudEVkaXRhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudFR5cGUgPSBhY3RpdmVFbGVtZW50LnR5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICBpc0NvbnRlbnRFZGl0YWJsZTogaXNDb250ZW50RWRpdGFibGUsXG4gICAgICBlbGVtZW50VHlwZTogZWxlbWVudFR5cGUsXG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBvbktleURvd24gPSAoZTogYW55LCBwYXJlbnRQb3J0OiBhbnkpID0+IHtcbiAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuS0VZX0RPV05fRVZFTlQsXG4gICAgICBldmVudDoge1xuICAgICAgICBrZXk6IGUua2V5LFxuICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gICAgICAgIGFjdGl2ZUVsZW1lbnQ6IHtcbiAgICAgICAgICAuLi5hY3RpdmVFbGVtZW50TWV0YWRhdGEoKSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3Qgb25LZXlVcCA9IChlOiBhbnksIHBhcmVudFBvcnQ6IGFueSkgPT4ge1xuICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgaWQ6IEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5LRVlfVVBfRVZFTlQsXG4gICAgICBldmVudDoge1xuICAgICAgICBrZXk6IGUua2V5LFxuICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gICAgICAgIGFjdGl2ZUVsZW1lbnQ6IHtcbiAgICAgICAgICAuLi5hY3RpdmVFbGVtZW50TWV0YWRhdGEoKSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3Qgb25TY3JvbGwgPSAoZTogYW55LCBwYXJlbnRQb3J0OiBhbnksIHN0b3J5Ym9hcmRJZDogc3RyaW5nKSA9PiB7XG4gICAgLy8gTGV0IHVwZGF0ZU91dGxpbmVzIGhhbmRsZSBpdHMgb3duIHRocm90dGxpbmcgdGhyb3VnaCB0aGUgZ2xvYmFsIG1lc3NhZ2Ugc3lzdGVtXG4gICAgdXBkYXRlT3V0bGluZXMocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgfTtcblxuICAvLyBOZWVkIHRvIHJlZ2lzdGVyIGZ1bmN0aW9ucyBvbiB0aGUgd2luZG93IGZvciBjaGFubmVsIG1lc3NhZ2luZyB0byB1c2UgdGhlbVxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy5pbml0UHJvamVjdCA9IChcbiAgICBwYXJlbnRQb3J0OiBhbnksXG4gICAgc3Rvcnlib2FyZElkOiBzdHJpbmcsXG4gICAgdHJlZUVsZW1lbnRMb29rdXA6IHt9LFxuICAgIHNjb3BlTG9va3VwOiB7fSxcbiAgICBzdG9yeWJvYXJkQ29tcG9uZW50RWxlbWVudD86IGFueSxcbiAgICBvcHRpb25zOiB7XG4gICAgICBkcml2ZU1vZGVFbmFibGVkPzogYm9vbGVhbjtcbiAgICAgIGFpQ29udGV4dFNlbGVjdGlvbj86IGJvb2xlYW47XG4gICAgfSA9IHt9LFxuICAgIHN0b3J5Ym9hcmRUeXBlPzogc3RyaW5nLFxuICAgIHNhdmVkQ29tcG9uZW50RmlsZW5hbWU/OiBzdHJpbmcsXG4gICAgb3JpZ2luYWxTdG9yeWJvYXJkVXJsPzogc3RyaW5nLFxuICApID0+IHtcbiAgICBjb25zdCBwYXNzaXZlOiBhbnkgPSBtYWtlUGFzc2l2ZUV2ZW50T3B0aW9uKCk7XG4gICAgcGFzc2l2ZVsnY2FwdHVyZSddID0gdHJ1ZTtcblxuICAgIGNvbnN0IGJvZHkkID0gJCgnYm9keScpO1xuXG4gICAgc2V0TWVtb3J5U3RvcmFnZUl0ZW0oVFJFRV9FTEVNRU5UX0xPT0tVUCwgdHJlZUVsZW1lbnRMb29rdXApO1xuICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKFNDT1BFX0xPT0tVUCwgc2NvcGVMb29rdXApO1xuXG4gICAgaWYgKHN0b3J5Ym9hcmRDb21wb25lbnRFbGVtZW50KSB7XG4gICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbShTVE9SWUJPQVJEX0NPTVBPTkVOVCwgc3Rvcnlib2FyZENvbXBvbmVudEVsZW1lbnQpO1xuICAgIH1cblxuICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKFNUT1JZQk9BUkRfVFlQRSwgc3Rvcnlib2FyZFR5cGUpO1xuXG4gICAgc2V0TWVtb3J5U3RvcmFnZUl0ZW0oXG4gICAgICBTQVZFRF9TVE9SWUJPQVJEX0NPTVBPTkVOVF9GSUxFTkFNRSxcbiAgICAgIHNhdmVkQ29tcG9uZW50RmlsZW5hbWUsXG4gICAgKTtcblxuICAgIC8vIFRoZSBVUkwgdGhhdCB3YXMgb3JpZ2luYWxseSBsb2FkZWQgZm9yIHRoaXMgc3Rvcnlib2FyZCwgaXQgbWF5IGJlIGRpZmZlcmVudCBmcm9tIGhyZWZcbiAgICAvLyBpZiB0aGUgdXNlciBuYXZpZ2F0ZWQgYXdheSB0byBhIG5ldyByb3V0ZVxuICAgIGlmIChvcmlnaW5hbFN0b3J5Ym9hcmRVcmwpIHtcbiAgICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKE9SSUdJTkFMX1NUT1JZQk9BUkRfVVJMLCBvcmlnaW5hbFN0b3J5Ym9hcmRVcmwpO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGlmcmFtZSBvdXRsaW5lc1xuICAgIHJlbW92ZU1lbW9yeVN0b3JhZ2VJdGVtKFNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcbiAgICByZW1vdmVNZW1vcnlTdG9yYWdlSXRlbShIT1ZFUkVEX0VMRU1FTlRfS0VZKTtcbiAgICB1cGRhdGVPdXRsaW5lcyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuXG4gICAgLy8gUmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgY29uc3QgYm9keU9iamVjdCA9IGJvZHkkLmdldCgwKTtcbiAgICBib2R5T2JqZWN0Py5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ2NsaWNrJyxcbiAgICAgIChlOiBhbnkpID0+IHtcbiAgICAgICAgcGFzc1Rocm91Z2hFdmVudHNJZk5lZWRlZChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgfSxcbiAgICAgIHBhc3NpdmUsXG4gICAgKTtcbiAgICBib2R5T2JqZWN0Py5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ3BvaW50ZXJvdmVyJyxcbiAgICAgIChlOiBhbnkpID0+IHtcbiAgICAgICAgb25Qb2ludGVyT3ZlcihlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgfSxcbiAgICAgIHBhc3NpdmUsXG4gICAgKTtcbiAgICBib2R5T2JqZWN0Py5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ3BvaW50ZXJkb3duJyxcbiAgICAgIChlOiBhbnkpID0+IHtcbiAgICAgICAgb25Qb2ludGVyRG93bihlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgfSxcbiAgICAgIHBhc3NpdmUsXG4gICAgKTtcbiAgICBib2R5T2JqZWN0Py5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ3BvaW50ZXJ1cCcsXG4gICAgICAoZTogYW55KSA9PiB7XG4gICAgICAgIG9uUG9pbnRlclVwKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICB9LFxuICAgICAgcGFzc2l2ZSxcbiAgICApO1xuICAgIGJvZHlPYmplY3Q/LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAncG9pbnRlcm1vdmUnLFxuICAgICAgKGU6IGFueSkgPT4ge1xuICAgICAgICBvblBvaW50ZXJNb3ZlKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICB9LFxuICAgICAgcGFzc2l2ZSxcbiAgICApO1xuICAgIGJvZHlPYmplY3Q/LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAncG9pbnRlcmxlYXZlJyxcbiAgICAgIChlOiBhbnkpID0+IHtcbiAgICAgICAgcGFzc1Rocm91Z2hFdmVudHNJZk5lZWRlZChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgfSxcbiAgICAgIHBhc3NpdmUsXG4gICAgKTtcbiAgICBib2R5T2JqZWN0Py5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ2NvbnRleHRtZW51JyxcbiAgICAgIChlOiBhbnkpID0+IHtcbiAgICAgICAgb25DbGlja0VsZW1lbnRDb250ZXh0TWVudShlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgfSxcbiAgICAgIHBhc3NpdmUsXG4gICAgKTtcbiAgICBib2R5T2JqZWN0Py5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ2RibGNsaWNrJyxcbiAgICAgIChlOiBhbnkpID0+IHtcbiAgICAgICAgcGFzc1Rocm91Z2hFdmVudHNJZk5lZWRlZChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgfSxcbiAgICAgIHBhc3NpdmUsXG4gICAgKTtcblxuICAgIGJvZHlPYmplY3Q/LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAnbW91c2VvdmVyJyxcbiAgICAgIChlOiBhbnkpID0+IHtcbiAgICAgICAgcGFzc1Rocm91Z2hFdmVudHNJZk5lZWRlZChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgfSxcbiAgICAgIHBhc3NpdmUsXG4gICAgKTtcbiAgICBib2R5T2JqZWN0Py5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ21vdXNlb3V0JyxcbiAgICAgIChlOiBhbnkpID0+IHtcbiAgICAgICAgcGFzc1Rocm91Z2hFdmVudHNJZk5lZWRlZChlLCBwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgfSxcbiAgICAgIHBhc3NpdmUsXG4gICAgKTtcbiAgICBib2R5T2JqZWN0Py5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ21vdXNlbW92ZScsXG4gICAgICAoZTogYW55KSA9PiB7XG4gICAgICAgIHBhc3NUaHJvdWdoRXZlbnRzSWZOZWVkZWQoZSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgIH0sXG4gICAgICBwYXNzaXZlLFxuICAgICk7XG4gICAgYm9keU9iamVjdD8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdtb3VzZWRvd24nLFxuICAgICAgKGU6IGFueSkgPT4ge1xuICAgICAgICBwYXNzVGhyb3VnaEV2ZW50c0lmTmVlZGVkKGUsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICB9LFxuICAgICAgcGFzc2l2ZSxcbiAgICApO1xuICAgIGJvZHlPYmplY3Q/LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAnbW91c2V1cCcsXG4gICAgICAoZTogYW55KSA9PiB7XG4gICAgICAgIHBhc3NUaHJvdWdoRXZlbnRzSWZOZWVkZWQoZSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgIH0sXG4gICAgICBwYXNzaXZlLFxuICAgICk7XG4gICAgYm9keU9iamVjdD8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICd3aGVlbCcsXG4gICAgICAoZTogYW55KSA9PiB7XG4gICAgICAgIG9uV2hlZWwoZSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgIH0sXG4gICAgICBwYXNzaXZlLFxuICAgICk7XG5cbiAgICBib2R5T2JqZWN0Py5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ2tleWRvd24nLFxuICAgICAgKGU6IGFueSkgPT4ge1xuICAgICAgICBvbktleURvd24oZSwgcGFyZW50UG9ydCk7XG4gICAgICB9LFxuICAgICAgcGFzc2l2ZSxcbiAgICApO1xuXG4gICAgYm9keU9iamVjdD8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdrZXl1cCcsXG4gICAgICAoZTogYW55KSA9PiB7XG4gICAgICAgIG9uS2V5VXAoZSwgcGFyZW50UG9ydCk7XG4gICAgICB9LFxuICAgICAgcGFzc2l2ZSxcbiAgICApO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAnc2Nyb2xsJyxcbiAgICAgIChlOiBhbnkpID0+IHtcbiAgICAgICAgb25TY3JvbGwoZSwgcGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICAgIH0sXG4gICAgICBwYXNzaXZlLFxuICAgICk7XG5cbiAgICAvLyBIYWNrOiB0aGlzIGlzIHVzZWQgdG9cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ3BvaW50ZXJsb2NrY2hhbmdlJyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCAmJlxuICAgICAgICAgIGdldE1lbW9yeVN0b3JhZ2VJdGVtKElNTUVESUFURUxZX1JFTU9WRV9QT0lOVEVSX0xPQ0spXG4gICAgICAgICkge1xuICAgICAgICAgIGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaygpO1xuICAgICAgICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKElNTUVESUFURUxZX1JFTU9WRV9QT0lOVEVSX0xPQ0ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZhbHNlLFxuICAgICk7XG5cbiAgICBjb25zdCBkZWJvdW5jZUV4ZWN1dG9yID0gbmV3IERlYm91bmNlRXhlY3V0b3IoKTtcblxuICAgIGNvbnN0IG9ianNUb09ic2VydmUgPSBbYm9keU9iamVjdCBhcyBIVE1MRWxlbWVudF07XG4gICAgY29uc3QgbmV4dEJ1aWxkV2F0Y2hlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX25leHQtYnVpbGQtd2F0Y2hlcicpO1xuICAgIGlmIChuZXh0QnVpbGRXYXRjaGVyICYmIG5leHRCdWlsZFdhdGNoZXIuc2hhZG93Um9vdCkge1xuICAgICAgLy8gSWYgdGhpcyBpcyBOZXh0SlMsIGFsc28gbGlzdGVuIHRvIHRoZSBzaGFkb3cgcm9vdCBvZiB0aGUgX19uZXh0LWJ1aWxkLXdhdGNoZXJcbiAgICAgIC8vIFRoaXMgdHJpZ2dlcmVzIHRoZSBvbkRPTUNoYW5nZWQgd2hlbiB0aGUgaG90IHJlbG9hZCBzeW1ib2wgc2hvd3MgdXBcbiAgICAgIG9ianNUb09ic2VydmUucHVzaChcbiAgICAgICAgLi4uKEFycmF5LmZyb20obmV4dEJ1aWxkV2F0Y2hlci5zaGFkb3dSb290LmNoaWxkcmVuKSBhcyBIVE1MRWxlbWVudFtdKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZ2xvYmFsVUlVcGRhdGVSdW5uZXIgPSBvYnNlcnZlRE9NKG9ianNUb09ic2VydmUsIChlOiBhbnkpID0+IHtcbiAgICAgIGRlYm91bmNlRXhlY3V0b3Iuc2NoZWR1bGUoKCkgPT4ge1xuICAgICAgICBvbkRPTUNoYW5nZWQoe1xuICAgICAgICAgIG11dGF0aW9uczogZSxcbiAgICAgICAgICBwYXJlbnRQb3J0LFxuICAgICAgICAgIHN0b3J5Ym9hcmRJZCxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLmRyaXZlTW9kZUVuYWJsZWQpIHtcbiAgICAgIGVuYWJsZURyaXZlTW9kZShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNhYmxlRHJpdmVNb2RlKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWlDb250ZXh0U2VsZWN0aW9uKSB7XG4gICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbSgnYWlDb250ZXh0JywgdHJ1ZSk7XG4gICAgICB1cGRhdGVPdXRsaW5lcyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbSgnYWlDb250ZXh0JywgZmFsc2UpO1xuICAgICAgdXBkYXRlT3V0bGluZXMocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgTmF2IFRyZWUgYW5kIHNlbmQgaXQgYmFja1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxVSVVwZGF0ZVJ1bm5lcigoKSA9PiB7XG4gICAgICAgIGJ1aWxkQW5kU2VuZE5hdlRyZWUoXG4gICAgICAgICAgcGFyZW50UG9ydCxcbiAgICAgICAgICBzdG9yeWJvYXJkSWQsXG4gICAgICAgICAgdHJlZUVsZW1lbnRMb29rdXAsXG4gICAgICAgICAgc2NvcGVMb29rdXAsXG4gICAgICAgICAgc3Rvcnlib2FyZENvbXBvbmVudEVsZW1lbnQgfHwgJ0VYUExJQ0lUX05PTkUnLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBidWlsZGluZyBuYXYgdHJlZTogJyArIGUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBlbmFibGVEcml2ZU1vZGUgPSAocGFyZW50UG9ydDogYW55LCBzdG9yeWJvYXJkSWQ6IHN0cmluZykgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoIWdldFNlc3Npb25TdG9yYWdlSXRlbSgnZHJpdmVNb2RlRW5hYmxlZCcsIHN0b3J5Ym9hcmRJZCkpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHNldFNlc3Npb25TdG9yYWdlSXRlbSgnZHJpdmVNb2RlRW5hYmxlZCcsICdlbmFibGVkJywgc3Rvcnlib2FyZElkKTtcbiAgICAgIGNsZWFySG92ZXJlZEVsZW1lbnRzKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICBjbGVhckFsbE91dGxpbmVzKCk7XG4gICAgfVxuXG4gICAgJCgnYm9keScpLmNzcygnY3Vyc29yJywgJycpO1xuICB9O1xuXG4gIGNvbnN0IGRpc2FibGVEcml2ZU1vZGUgPSAocGFyZW50UG9ydDogYW55LCBzdG9yeWJvYXJkSWQ6IHN0cmluZykgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoZ2V0U2Vzc2lvblN0b3JhZ2VJdGVtKCdkcml2ZU1vZGVFbmFibGVkJywgc3Rvcnlib2FyZElkKSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmVtb3ZlU2Vzc2lvblN0b3JhZ2VJdGVtKCdkcml2ZU1vZGVFbmFibGVkJywgc3Rvcnlib2FyZElkKTtcbiAgICAgIHVwZGF0ZU91dGxpbmVzKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgICBjbGVhckhvdmVyZWRFbGVtZW50cyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgIH1cblxuICAgICQoJ2JvZHknKS5hdHRyKCdzdHlsZScsIGZ1bmN0aW9uIChpLCBzKSB7XG4gICAgICByZXR1cm4gKHMgfHwgJycpICsgJ2N1cnNvcjogZGVmYXVsdCAhaW1wb3J0YW50Oyc7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuZW5hYmxlRHJpdmVNb2RlID0gKHBhcmVudFBvcnQ6IGFueSwgc3Rvcnlib2FyZElkOiBzdHJpbmcpID0+IHtcbiAgICBlbmFibGVEcml2ZU1vZGUocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgfTtcblxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy5kaXNhYmxlRHJpdmVNb2RlID0gKHBhcmVudFBvcnQ6IGFueSwgc3Rvcnlib2FyZElkOiBzdHJpbmcpID0+IHtcbiAgICBkaXNhYmxlRHJpdmVNb2RlKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuc2V0TmV3TG9va3VwcyA9IChcbiAgICBwYXJlbnRQb3J0OiBhbnksXG4gICAgc3Rvcnlib2FyZElkOiBzdHJpbmcsXG4gICAgdHJlZUVsZW1lbnRMb29rdXA6IGFueSxcbiAgICBzY29wZUxvb2t1cDogYW55LFxuICApID0+IHtcbiAgICBjb25zdCBwcmV2VHJlZUVsZW1udExvb2t1cCA9XG4gICAgICBnZXRNZW1vcnlTdG9yYWdlSXRlbShUUkVFX0VMRU1FTlRfTE9PS1VQKSB8fCB7fTtcblxuICAgIGNvbnN0IHByZXZTY29wZUxvb2t1cCA9IGdldE1lbW9yeVN0b3JhZ2VJdGVtKFNDT1BFX0xPT0tVUCkgfHwge307XG5cbiAgICBjb25zdCBuZXdUcmVlRWxlbWVudHM6IGFueSA9IHtcbiAgICAgIC4uLnByZXZUcmVlRWxlbW50TG9va3VwLFxuICAgIH07XG5cbiAgICAvLyBEZWxldGUgYW55IHRyZWUgZWxlbWVudHMgdGhhdCB3ZXJlIHNldCB0byBudWxcbiAgICBPYmplY3Qua2V5cyh0cmVlRWxlbWVudExvb2t1cCkuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IHtcbiAgICAgIGlmICh0cmVlRWxlbWVudExvb2t1cFtrZXldKSB7XG4gICAgICAgIG5ld1RyZWVFbGVtZW50c1trZXldID0gdHJlZUVsZW1lbnRMb29rdXBba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAobmV3VHJlZUVsZW1lbnRzW2tleV0pIHtcbiAgICAgICAgZGVsZXRlIG5ld1RyZWVFbGVtZW50c1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgbmV3U2NvcGVzOiBhbnkgPSB7XG4gICAgICAuLi5wcmV2U2NvcGVMb29rdXAsXG4gICAgfTtcblxuICAgIC8vIERlbGV0ZSBhbnkgc2NvcGVzIHRoYXQgd2VyZSBzZXQgdG8gbnVsXG4gICAgT2JqZWN0LmtleXMoc2NvcGVMb29rdXApLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoc2NvcGVMb29rdXBba2V5XSkge1xuICAgICAgICBuZXdTY29wZXNba2V5XSA9IHNjb3BlTG9va3VwW2tleV07XG4gICAgICB9IGVsc2UgaWYgKG5ld1Njb3Blc1trZXldKSB7XG4gICAgICAgIGRlbGV0ZSBuZXdTY29wZXNba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKFRSRUVfRUxFTUVOVF9MT09LVVAsIG5ld1RyZWVFbGVtZW50cyk7XG4gICAgc2V0TWVtb3J5U3RvcmFnZUl0ZW0oU0NPUEVfTE9PS1VQLCBuZXdTY29wZXMpO1xuICB9O1xuXG4gIC8vIEB0cy1pZ25vcmVcbiAgd2luZG93LnNldEhvdmVyZWRFbGVtZW50ID0gKFxuICAgIHBhcmVudFBvcnQ6IGFueSxcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZyxcbiAgICBlbGVtZW50S2V5OiBzdHJpbmcsXG4gICkgPT4ge1xuICAgIGNvbnN0IGRyaXZlTW9kZUVuYWJsZWQgPSAhIWdldFNlc3Npb25TdG9yYWdlSXRlbShcbiAgICAgICdkcml2ZU1vZGVFbmFibGVkJyxcbiAgICAgIHN0b3J5Ym9hcmRJZCxcbiAgICApO1xuICAgIGlmIChkcml2ZU1vZGVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcHJldkhvdmVyZWRFbGVtZW50S2V5ID0gZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oSE9WRVJFRF9FTEVNRU5UX0tFWSk7XG4gICAgaWYgKHByZXZIb3ZlcmVkRWxlbWVudEtleSA9PT0gZWxlbWVudEtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50S2V5KSB7XG4gICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbShIT1ZFUkVEX0VMRU1FTlRfS0VZLCBlbGVtZW50S2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTWVtb3J5U3RvcmFnZUl0ZW0oSE9WRVJFRF9FTEVNRU5UX0tFWSk7XG4gICAgfVxuXG4gICAgdXBkYXRlT3V0bGluZXMocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgfTtcblxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy5zZXRTZWxlY3RlZEVsZW1lbnQgPSAoXG4gICAgcGFyZW50UG9ydDogYW55LFxuICAgIHN0b3J5Ym9hcmRJZDogc3RyaW5nLFxuICAgIGVsZW1lbnRLZXk6IHN0cmluZyxcbiAgKSA9PiB7XG4gICAgY29uc3QgcHJldlNlbGVjdGVkRWxlbWVudEtleSA9IGdldE1lbW9yeVN0b3JhZ2VJdGVtKFNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcbiAgICBpZiAocHJldlNlbGVjdGVkRWxlbWVudEtleSA9PT0gZWxlbWVudEtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50S2V5KSB7XG4gICAgICBjb25zdCB0ZW1wb0VsZW1lbnQgPSBUZW1wb0VsZW1lbnQuZnJvbUtleShlbGVtZW50S2V5KTtcbiAgICAgIGxldCBlbGVtZW50S2V5VG9FeHRyYWN0ID0gZWxlbWVudEtleTtcblxuICAgICAgaWYgKHRlbXBvRWxlbWVudC5pc1N0b3J5Ym9hcmQoc3Rvcnlib2FyZElkKSkge1xuICAgICAgICAvLyBQYXNzIGJhY2sgdGhlIG91dGVySFRNTCBvZiB0aGUgdG9wIGxldmVsIG5vZGVcbiAgICAgICAgY29uc3QgdG9wTGV2ZWxOb2RlOiBOYXZUcmVlTm9kZSA9XG4gICAgICAgICAgZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oQ1VSUkVOVF9OQVZfVFJFRSk7XG4gICAgICAgIGNvbnN0IHRvcExldmVsRWxlbWVudEtleSA9IHRvcExldmVsTm9kZT8udGVtcG9FbGVtZW50Py5nZXRLZXkoKTtcbiAgICAgICAgaWYgKHRvcExldmVsRWxlbWVudEtleSkge1xuICAgICAgICAgIGVsZW1lbnRLZXlUb0V4dHJhY3QgPSB0b3BMZXZlbEVsZW1lbnRLZXk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2VuZCBiYWNrIHRoZSBtZXNzYWdlIGp1c3QgdG8gc2V0IHRoZSBvdXRlckhUTUwgb25seVxuICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuU0VMRUNURURfRUxFTUVOVF9LRVksXG4gICAgICAgIGRvTm90U2V0RWxlbWVudEtleTogdHJ1ZSxcbiAgICAgICAgb3V0ZXJIVE1MOiBnZXRGdWxsSHRtbFdpdGhFbGVtZW50KFtlbGVtZW50S2V5VG9FeHRyYWN0XSksXG4gICAgICB9KTtcbiAgICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKFNFTEVDVEVEX0VMRU1FTlRfS0VZLCBlbGVtZW50S2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuU0VMRUNURURfRUxFTUVOVF9LRVksXG4gICAgICAgIGRvTm90U2V0RWxlbWVudEtleTogdHJ1ZSxcbiAgICAgICAgb3V0ZXJIVE1MOiBudWxsLFxuICAgICAgfSk7XG4gICAgICByZW1vdmVNZW1vcnlTdG9yYWdlSXRlbShTRUxFQ1RFRF9FTEVNRU5UX0tFWSk7XG4gICAgfVxuXG4gICAgdXBkYXRlT3V0bGluZXMocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgfTtcblxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy5zZXRNdWx0aXNlbGVjdGVkRWxlbWVudEtleXMgPSAoXG4gICAgcGFyZW50UG9ydDogYW55LFxuICAgIHN0b3J5Ym9hcmRJZDogc3RyaW5nLFxuICAgIGVsZW1lbnRLZXlzOiBzdHJpbmdbXSxcbiAgKSA9PiB7XG4gICAgY29uc3QgcHJldk11bHRpU2VsZWN0ZWRFbGVtZW50S2V5cyA9IGdldE1lbW9yeVN0b3JhZ2VJdGVtKFxuICAgICAgTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTLFxuICAgICk7XG4gICAgY29uc3QgcHJldlNldCA9IG5ldyBTZXQocHJldk11bHRpU2VsZWN0ZWRFbGVtZW50S2V5cyB8fCBbXSk7XG4gICAgY29uc3QgbmV3U2V0ID0gbmV3IFNldChlbGVtZW50S2V5cyB8fCBbXSk7XG4gICAgY29uc3Qgc2V0c0VxdWFsID1cbiAgICAgIHByZXZTZXQuc2l6ZSA9PT0gbmV3U2V0LnNpemUgJiZcbiAgICAgIFsuLi5wcmV2U2V0XS5ldmVyeSgodmFsdWU6IGFueSkgPT4gbmV3U2V0Lmhhcyh2YWx1ZSkpO1xuICAgIGlmIChzZXRzRXF1YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudEtleXMpIHtcbiAgICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKE1VTFRJX1NFTEVDVEVEX0VMRU1FTlRfS0VZUywgZWxlbWVudEtleXMpO1xuICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTLFxuICAgICAgICBkb05vdFNldEVsZW1lbnRLZXlzOiB0cnVlLFxuICAgICAgICBvdXRlckhUTUxzOiBnZXRGdWxsSHRtbFdpdGhFbGVtZW50KGVsZW1lbnRLZXlzKSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVNZW1vcnlTdG9yYWdlSXRlbShNVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMpO1xuICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuTVVMVElfU0VMRUNURURfRUxFTUVOVF9LRVlTLFxuICAgICAgICBkb05vdFNldEVsZW1lbnRLZXlzOiB0cnVlLFxuICAgICAgICBvdXRlckhUTUxzOiBbXSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZU91dGxpbmVzKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cucHJvY2Vzc1J1bGVzRm9yU2VsZWN0ZWRFbGVtZW50ID0gKFxuICAgIHBhcmVudFBvcnQ6IGFueSxcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZyxcbiAgICBjc3NFbGVtZW50TG9va3VwOiB7fSxcbiAgICBzZWxlY3RlZEVsZW1lbnRLZXk6IHN0cmluZyxcbiAgKSA9PiB7XG4gICAgcHJvY2Vzc1J1bGVzRm9yU2VsZWN0ZWRFbGVtZW50KFxuICAgICAgcGFyZW50UG9ydCxcbiAgICAgIGNzc0VsZW1lbnRMb29rdXAsXG4gICAgICBzZWxlY3RlZEVsZW1lbnRLZXksXG4gICAgKTtcbiAgfTtcblxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy5zZXRNb2RpZmllcnNGb3JTZWxlY3RlZEVsZW1lbnQgPSAoXG4gICAgcGFyZW50UG9ydDogYW55LFxuICAgIHN0b3J5Ym9hcmRJZDogc3RyaW5nLFxuICAgIG1vZGlmaWVyczogYW55LFxuICAgIHNlbGVjdGVkRWxlbWVudEtleTogc3RyaW5nLFxuICApID0+IHtcbiAgICBzZXRNb2RpZmllcnNGb3JTZWxlY3RlZEVsZW1lbnQocGFyZW50UG9ydCwgbW9kaWZpZXJzLCBzZWxlY3RlZEVsZW1lbnRLZXkpO1xuICB9O1xuXG4gIC8vIEB0cy1pZ25vcmVcbiAgd2luZG93LmdldENzc0V2YWxzID0gKFxuICAgIHBhcmVudFBvcnQ6IGFueSxcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZyxcbiAgICBzZWxlY3RlZEVsZW1lbnRLZXk6IHN0cmluZyxcbiAgKSA9PiB7XG4gICAgZ2V0Q3NzRXZhbHMocGFyZW50UG9ydCwgc2VsZWN0ZWRFbGVtZW50S2V5KTtcbiAgfTtcblxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy5ydWxlTWF0Y2hlc0VsZW1lbnQgPSAoXG4gICAgcGFyZW50UG9ydDogYW55LFxuICAgIHN0b3J5Ym9hcmRJZDogc3RyaW5nLFxuICAgIG1lc3NhZ2VJZDogc3RyaW5nLFxuICAgIHJ1bGU6IHN0cmluZyxcbiAgICBzZWxlY3RlZEVsZW1lbnRLZXk6IHN0cmluZyxcbiAgKSA9PiB7XG4gICAgcnVsZU1hdGNoZXNFbGVtZW50KHBhcmVudFBvcnQsIG1lc3NhZ2VJZCwgcnVsZSwgc2VsZWN0ZWRFbGVtZW50S2V5KTtcbiAgfTtcblxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy5nZXRFbGVtZW50Q2xhc3NMaXN0ID0gKFxuICAgIHBhcmVudFBvcnQ6IGFueSxcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZyxcbiAgICBzZWxlY3RlZEVsZW1lbnRLZXk6IHN0cmluZyxcbiAgKSA9PiB7XG4gICAgZ2V0RWxlbWVudENsYXNzTGlzdChwYXJlbnRQb3J0LCBzZWxlY3RlZEVsZW1lbnRLZXkpO1xuICB9O1xuXG4gIC8vIEB0cy1pZ25vcmVcbiAgd2luZG93LmFwcGx5Q2hhbmdlSXRlbVRvRG9jdW1lbnQgPSBhc3luYyAoXG4gICAgcGFyZW50UG9ydDogYW55LFxuICAgIHN0b3J5Ym9hcmRJZDogc3RyaW5nLFxuICAgIGNoYW5nZUl0ZW06IEFueUNoYW5nZUxlZGdlckl0ZW0sXG4gICkgPT4ge1xuICAgIGNvbnN0IHsgc2VuZE5ld05hdlRyZWUgfSA9IGFwcGx5Q2hhbmdlSXRlbVRvRG9jdW1lbnQoXG4gICAgICBwYXJlbnRQb3J0LFxuICAgICAgc3Rvcnlib2FyZElkLFxuICAgICAgY2hhbmdlSXRlbSxcbiAgICApO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBuYXYgdHJlZSAmIG91dGxpbmVzXG4gICAgaWYgKHNlbmROZXdOYXZUcmVlKSB7XG4gICAgICBhd2FpdCBidWlsZEFuZFNlbmROYXZUcmVlKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgfVxuICAgIHVwZGF0ZU91dGxpbmVzKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cudXBkYXRlQ29kZWJhc2VJZHMgPSBhc3luYyAoXG4gICAgcGFyZW50UG9ydDogYW55LFxuICAgIHN0b3J5Ym9hcmRJZDogc3RyaW5nLFxuICAgIHByZXZJZFRvTmV3SWRNYXA6IHsgW3ByZXZDb2RlYmFzZUlkOiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgICBuZXdUcmVlRWxlbWVudExvb2t1cDogYW55LFxuICAgIG5ld1Njb3BlTG9va3VwOiBhbnksXG4gICkgPT4ge1xuICAgIGNvbnN0IHNlbmROZXdOYXZUcmVlID0gdXBkYXRlQ29kZWJhc2VJZHMoXG4gICAgICBwYXJlbnRQb3J0LFxuICAgICAgcHJldklkVG9OZXdJZE1hcCxcbiAgICAgIHRydWUsXG4gICAgKTtcblxuICAgIGlmIChzZW5kTmV3TmF2VHJlZSkge1xuICAgICAgYXdhaXQgYnVpbGRBbmRTZW5kTmF2VHJlZShcbiAgICAgICAgcGFyZW50UG9ydCxcbiAgICAgICAgc3Rvcnlib2FyZElkLFxuICAgICAgICBuZXdUcmVlRWxlbWVudExvb2t1cCxcbiAgICAgICAgbmV3U2NvcGVMb29rdXAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHVwZGF0ZU91dGxpbmVzKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9IChcbiAgICBwYXJlbnRQb3J0OiBhbnksXG4gICAgc3Rvcnlib2FyZElkOiBzdHJpbmcsXG4gICAgZXZlbnROYW1lOiBzdHJpbmcsXG4gICAgZXZlbnREZXRhaWxzOiBhbnksXG4gICkgPT4ge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwge1xuICAgICAgLi4uZXZlbnREZXRhaWxzLFxuICAgIH0pO1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9O1xuXG4gIC8vIEB0cy1pZ25vcmVcbiAgd2luZG93LnVwZGF0ZU91dGxpbmVzID0gKHBhcmVudFBvcnQ6IGFueSwgc3Rvcnlib2FyZElkOiBzdHJpbmcpID0+IHtcbiAgICB1cGRhdGVPdXRsaW5lcyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICB9O1xuXG4gIC8vIEB0cy1pZ25vcmVcbiAgd2luZG93LmdvQmFjayA9IChwYXJlbnRQb3J0OiBhbnksIHN0b3J5Ym9hcmRJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKGRvY3VtZW50LnJlZmVycmVyICE9PSAnJykge1xuICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy5nb0ZvcndhcmQgPSAocGFyZW50UG9ydDogYW55LCBzdG9yeWJvYXJkSWQ6IHN0cmluZykgPT4ge1xuICAgIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKTtcbiAgfTtcblxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy5yZWZyZXNoID0gKHBhcmVudFBvcnQ6IGFueSwgc3Rvcnlib2FyZElkOiBzdHJpbmcpID0+IHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuc3ludGhldGljTW91c2VPdmVyID0gKFxuICAgIHBhcmVudFBvcnQ6IGFueSxcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZyxcbiAgICBjb29yZHM6IGFueSxcbiAgICBkb250SG92ZXJJbnNpZGVTZWxlY3RlZDogYm9vbGVhbixcbiAgICBzZWxlY3RCb3R0b21Nb3N0RWxlbWVudDogYm9vbGVhbixcbiAgKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChjb29yZHMueCwgY29vcmRzLnkpO1xuXG4gICAgLy8gSWYgdGhpcyBpcyB0cnVlIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhIGhvdmVyIGV2ZW50IGluc2lkZSBhIHNlbGVjdGVkIGVsZW1lbnQsIGluc3RlYWQganVzdCBzZXQgaG92ZXJpbmcgb24gdGhlIHNlbGVjdGVkIGVsZW1lbnRcbiAgICBpZiAoZG9udEhvdmVySW5zaWRlU2VsZWN0ZWQpIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkRWxlbWVudEtleSA9IGdldE1lbW9yeVN0b3JhZ2VJdGVtKFNFTEVDVEVEX0VMRU1FTlRfS0VZKTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkRWxlbWVudCA9IFRlbXBvRWxlbWVudC5mcm9tS2V5KHNlbGVjdGVkRWxlbWVudEtleSk7XG5cbiAgICAgIGlmICghc2VsZWN0ZWRFbGVtZW50LmlzRW1wdHkoKSkge1xuICAgICAgICBjb25zdCBzZWxlY3RlZERvbUVsZW1lbnQgPSBnZXROb2RlRm9yRWxlbWVudEtleShzZWxlY3RlZEVsZW1lbnRLZXkpO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZERvbUVsZW1lbnQ/LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICBvblBvaW50ZXJPdmVyKFxuICAgICAgICAgICAgeyB0YXJnZXQ6IHNlbGVjdGVkRG9tRWxlbWVudCB9LFxuICAgICAgICAgICAgcGFyZW50UG9ydCxcbiAgICAgICAgICAgIHN0b3J5Ym9hcmRJZCxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG9uUG9pbnRlck92ZXIoXG4gICAgICB7IHRhcmdldCB9LFxuICAgICAgcGFyZW50UG9ydCxcbiAgICAgIHN0b3J5Ym9hcmRJZCxcbiAgICAgIHNlbGVjdEJvdHRvbU1vc3RFbGVtZW50LFxuICAgICk7XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuc3ludGhldGljTW91c2VNb3ZlID0gKFxuICAgIHBhcmVudFBvcnQ6IGFueSxcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZyxcbiAgICBzeW50aGV0aWNFdmVudDoge1xuICAgICAgY2xpZW50WDogbnVtYmVyO1xuICAgICAgY2xpZW50WTogbnVtYmVyO1xuICAgICAgYnV0dG9ucz86IG51bWJlcjtcbiAgICB9LFxuICApID0+IHtcbiAgICBjb25zdCBldmVudFdpdGhDbGllbnQgPSB7XG4gICAgICAuLi5zeW50aGV0aWNFdmVudCxcbiAgICAgIHBhZ2VYOlxuICAgICAgICBzeW50aGV0aWNFdmVudC5jbGllbnRYICtcbiAgICAgICAgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCksXG4gICAgICBwYWdlWTpcbiAgICAgICAgc3ludGhldGljRXZlbnQuY2xpZW50WSArXG4gICAgICAgIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKSxcbiAgICB9O1xuXG4gICAgb25Qb2ludGVyTW92ZShldmVudFdpdGhDbGllbnQsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuc3ludGhldGljTW91c2VVcCA9IChcbiAgICBwYXJlbnRQb3J0OiBhbnksXG4gICAgc3Rvcnlib2FyZElkOiBzdHJpbmcsXG4gICAgc3ludGhldGljRXZlbnQ6IGFueSxcbiAgKSA9PiB7XG4gICAgb25Qb2ludGVyVXAoc3ludGhldGljRXZlbnQsIHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuY2xlYXJIb3ZlcmVkT3V0bGluZXMgPSAocGFyZW50UG9ydDogYW55LCBzdG9yeWJvYXJkSWQ6IHN0cmluZykgPT4ge1xuICAgIGlmIChnZXRNZW1vcnlTdG9yYWdlSXRlbShIT1ZFUkVEX0VMRU1FTlRfS0VZKSkge1xuICAgICAgY2xlYXJIb3ZlcmVkRWxlbWVudHMocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuc2V0Wm9vbVBlcmMgPSAoXG4gICAgcGFyZW50UG9ydDogYW55LFxuICAgIHN0b3J5Ym9hcmRJZDogc3RyaW5nLFxuICAgIHpvb21QZXJjOiBudW1iZXIsXG4gICkgPT4ge1xuICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKCd6b29tUGVyYycsIHpvb21QZXJjLnRvU3RyaW5nKCkpO1xuICAgIHVwZGF0ZU91dGxpbmVzKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuc2V0QWlDb250ZXh0ID0gKFxuICAgIHBhcmVudFBvcnQ6IGFueSxcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZyxcbiAgICBhaUNvbnRleHQ6IGJvb2xlYW4sXG4gICkgPT4ge1xuICAgIHNldE1lbW9yeVN0b3JhZ2VJdGVtKCdhaUNvbnRleHQnLCAhIWFpQ29udGV4dCk7XG4gICAgdXBkYXRlT3V0bGluZXMocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgfTtcblxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy50ZW1wTW92ZUVsZW1lbnQgPSBhc3luYyAoXG4gICAgcGFyZW50UG9ydDogYW55LFxuICAgIHN0b3J5Ym9hcmRJZDogc3RyaW5nLFxuICAgIG5vZGVUb01vdmVFbGVtZW50S2V5OiBzdHJpbmcsXG4gICAgbmV3SW5kZXg6IG51bWJlcixcbiAgKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudEtleVRvTmF2Tm9kZSA9XG4gICAgICBnZXRNZW1vcnlTdG9yYWdlSXRlbShFTEVNRU5UX0tFWV9UT19OQVZfTk9ERSkgfHwge307XG5cbiAgICBjb25zdCBuYXZOb2RlVG9Nb3ZlID0gZWxlbWVudEtleVRvTmF2Tm9kZVtub2RlVG9Nb3ZlRWxlbWVudEtleV07XG4gICAgaWYgKCFuYXZOb2RlVG9Nb3ZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZVRvTW92ZUVsZW1lbnQgPSBUZW1wb0VsZW1lbnQuZnJvbUtleShub2RlVG9Nb3ZlRWxlbWVudEtleSk7XG5cbiAgICBjb25zdCBkb21FbGVtZW50c1RvTW92ZTogYW55W10gPSBbXTtcbiAgICAvLyBJbiBjb21wb25lbnRzLCB0aGVyZSBtYXkgYmUgbXVsdGlwbGUgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGJlIG1vdmVkLCB0aGUgZWxlZW1udEtleVRvTG9va3VwTGlzdFxuICAgIC8vIGFyZSBhbGwgdGhlIHJlYWwgRE9NIGVsZW1lbnRzIGluIGEgY29tcG9uZW50XG4gICAgLy8gRm9yIG5vbi1jb21wb25lbnRzLCB0aGUgZWxlZW1udEtleVRvTG9va3VwTGlzdCBwb2ludHMgdG8gYSBsaXN0IG9mIGl0c2VsZlxuICAgIGNvbnN0IGVsZW1lbnRLZXlUb0xvb2t1cExpc3Q6IGFueSA9XG4gICAgICBnZXRNZW1vcnlTdG9yYWdlSXRlbShFTEVNRU5UX0tFWV9UT19MT09LVVBfTElTVCkgfHwge307XG4gICAgY29uc3QgbG9va3VwTGlzdCA9XG4gICAgICBlbGVtZW50S2V5VG9Mb29rdXBMaXN0W25hdk5vZGVUb01vdmUudGVtcG9FbGVtZW50LmdldEtleSgpXSB8fCBbXTtcbiAgICBsb29rdXBMaXN0LmZvckVhY2goKGxvb2t1cEVsZW1lbnRLZXk6IHN0cmluZykgPT4ge1xuICAgICAgZG9tRWxlbWVudHNUb01vdmUucHVzaChnZXROb2RlRm9yRWxlbWVudEtleShsb29rdXBFbGVtZW50S2V5KSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBwYXJlbnREb21FbGVtZW50ID0gZG9tRWxlbWVudHNUb01vdmVbMF0/LnBhcmVudEVsZW1lbnQ7XG4gICAgY29uc3QgcGFyZW50TmF2Tm9kZSA9IG5hdk5vZGVUb01vdmUucGFyZW50O1xuXG4gICAgaWYgKHBhcmVudERvbUVsZW1lbnQgJiYgcGFyZW50TmF2Tm9kZSkge1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gcGFyZW50TmF2Tm9kZT8uY2hpbGRyZW4/LmluZGV4T2YobmF2Tm9kZVRvTW92ZSk7XG4gICAgICBjb25zdCBudW1DaGlsZHJlbiA9IHBhcmVudE5hdk5vZGU/LmNoaWxkcmVuPy5sZW5ndGg7XG5cbiAgICAgIGlmIChjdXJyZW50SW5kZXggIT09IG5ld0luZGV4KSB7XG4gICAgICAgIEFycmF5LmZyb20ocGFyZW50RG9tRWxlbWVudC5jaGlsZHJlbikuZm9yRWFjaCgoY2hpbGQ6IGFueSkgPT4ge1xuICAgICAgICAgICQoY2hpbGQpLmF0dHIoVEVNUE9fSU5TVEFOVF9VUERBVEUsICd0cnVlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQocGFyZW50RG9tRWxlbWVudCkuYXR0cihURU1QT19JTlNUQU5UX1VQREFURSwgJ3RydWUnKTtcblxuICAgICAgICBpZiAobmV3SW5kZXggPT09IG51bUNoaWxkcmVuIC0gMSkge1xuICAgICAgICAgIGRvbUVsZW1lbnRzVG9Nb3ZlLmZvckVhY2goKGVsZW1lbnQ6IGFueSkgPT4ge1xuICAgICAgICAgICAgZWxlbWVudC5wYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGluZGV4IGlzIGJlZm9yZSB0aGUgbmV3IGluZGV4IHRoZW4gd2UgbmVlZCB0byBhZGp1c3QgYnkgMSB0byBhY2NvdW50IGZvciB0aGUgc2hpZnQgaW4gaW5kaWNlc1xuICAgICAgICAgIGNvbnN0IGJlZm9yZU5vZGUgPVxuICAgICAgICAgICAgY3VycmVudEluZGV4ID4gbmV3SW5kZXhcbiAgICAgICAgICAgICAgPyBwYXJlbnROYXZOb2RlPy5jaGlsZHJlbltuZXdJbmRleF1cbiAgICAgICAgICAgICAgOiBwYXJlbnROYXZOb2RlPy5jaGlsZHJlbltuZXdJbmRleCArIDFdO1xuICAgICAgICAgIGNvbnN0IGxvb2t1cExpc3RGb3JCZWZvcmUgPVxuICAgICAgICAgICAgZWxlbWVudEtleVRvTG9va3VwTGlzdFtiZWZvcmVOb2RlPy50ZW1wb0VsZW1lbnQ/LmdldEtleSgpXSB8fCBbXTtcblxuICAgICAgICAgIGlmICghbG9va3VwTGlzdEZvckJlZm9yZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDYW5ub3QgZmluZCBlbGVtZW50IHRvIGluc2VydCBiZWZvcmUgaW4gbG9va3VwIGxpc3QnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBiZWZvcmVEb21FbGVtZW50ID0gZ2V0Tm9kZUZvckVsZW1lbnRLZXkobG9va3VwTGlzdEZvckJlZm9yZVswXSk7XG5cbiAgICAgICAgICBpZiAoIWJlZm9yZURvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDYW5ub3QgZmluZCBlbGVtZW50IHRvIGluc2VydCBiZWZvcmUnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkb21FbGVtZW50c1RvTW92ZS5mb3JFYWNoKChlbGVtZW50OiBhbnkpID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnQucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYmVmb3JlRG9tRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHNlbGVjdGVkIGVsZW1lbnQga2V5IHRvIHRoZSBuZXcgZXhwZWN0ZWQgb25lIChub3RlIGlmIG1vdmluZyB0aGVyZSBpcyBubyBob3ZlcmVkIGVsZW1lbnQga2V5KVxuICAgICAgICAvLyBUaGlzIGFsc28gYXNzdW1lcyB0aGUgbm9kZVRvTW92ZUVsZW1lbnRLZXkgaXMgdGhlIHNlbGVjdGVkIGVsZW1lbnQga2V5XG4gICAgICAgIGNvbnN0IGVsZW1lbnRUb01vdmVTZWdtZW50cyA9IG5vZGVUb01vdmVFbGVtZW50LnVuaXF1ZVBhdGguc3BsaXQoJy0nKTtcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0ZWRVbmlxdWVQYXRoID1cbiAgICAgICAgICBlbGVtZW50VG9Nb3ZlU2VnbWVudHNcbiAgICAgICAgICAgIC5zbGljZSgwLCBlbGVtZW50VG9Nb3ZlU2VnbWVudHMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIC5qb2luKCctJykgKyBgLSR7bmV3SW5kZXh9YDtcblxuICAgICAgICBjb25zdCBuZXdTZWxlY3RlZEVsZW1lbnRLZXkgPSBuZXcgVGVtcG9FbGVtZW50KFxuICAgICAgICAgIG5vZGVUb01vdmVFbGVtZW50LmNvZGViYXNlSWQsXG4gICAgICAgICAgbm9kZVRvTW92ZUVsZW1lbnQuc3Rvcnlib2FyZElkLFxuICAgICAgICAgIG5ld1NlbGVjdGVkVW5pcXVlUGF0aCxcbiAgICAgICAgKS5nZXRLZXkoKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIG5hdiB0cmVlIHdoaWNoIGFsc28gc2V0cyB0aGUgZWxlbWVudCBrZXkgb24gYWxsIHRoZSBlbGVtZW50cywgbmVlZCB0byBkbyB0aGlzIGJlZm9yZVxuICAgICAgICAvLyB1cGRhdGluZyB0aGUgc2VsZWN0ZWQgZWxlbWVudCBrZXlcbiAgICAgICAgYXdhaXQgYnVpbGRBbmRTZW5kTmF2VHJlZShwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuXG4gICAgICAgIC8vIENvZGViYXNlIElEIGRvZXNuJ3QgY2hhbmdlXG4gICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuU0VMRUNURURfRUxFTUVOVF9LRVksXG4gICAgICAgICAgZWxlbWVudEtleTogbmV3U2VsZWN0ZWRFbGVtZW50S2V5LFxuICAgICAgICAgIG91dGVySFRNTDogZ2V0RnVsbEh0bWxXaXRoRWxlbWVudChbbmV3U2VsZWN0ZWRFbGVtZW50S2V5XSksXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbShTRUxFQ1RFRF9FTEVNRU5UX0tFWSwgbmV3U2VsZWN0ZWRFbGVtZW50S2V5KTtcblxuICAgICAgICB1cGRhdGVPdXRsaW5lcyhwYXJlbnRQb3J0LCBzdG9yeWJvYXJkSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy50ZW1wQWRkRGl2ID0gYXN5bmMgKFxuICAgIHBhcmVudFBvcnQ6IGFueSxcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZyxcbiAgICBwYXJlbnRDb2RlYmFzZUlkOiBzdHJpbmcsXG4gICAgaW5kZXhJblBhcmVudDogbnVtYmVyLFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gICkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSAkKGAuJHtURU1QT19JTlNUQU5UX0RJVl9EUkFXX0NMQVNTfWApO1xuICAgIGlmIChlbGVtZW50Lmxlbmd0aCkge1xuICAgICAgZWxlbWVudC5jc3MoJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgZWxlbWVudC5jc3MoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXJlbnQgPSAkKGAuJHtwYXJlbnRDb2RlYmFzZUlkfWApO1xuICAgICAgaWYgKCFwYXJlbnQubGVuZ3RoKSB7XG4gICAgICAgIHBhcmVudCA9ICQoJ2JvZHknKTtcbiAgICAgIH1cblxuICAgICAgcGFyZW50LmVhY2goKGluZGV4OiBhbnksIGl0ZW06IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdFbGVtZW50ID0gJChcbiAgICAgICAgICBgPGRpdiBjbGFzcz1cIiR7VEVNUE9fSU5TVEFOVF9ESVZfRFJBV19DTEFTU31cIiAke1RFTVBPX0RFTEVURV9BRlRFUl9JTlNUQU5UX1VQREFURX09XCJ0cnVlXCIgJHtURU1QT19ERUxFVEVfQUZURVJfUkVGUkVTSH09XCJ0cnVlXCIgJHtURU1QT19JTlNUQU5UX1VQREFURX09XCJ0cnVlXCI+PC9kaXY+YCxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBjaGlsZEF0SW5kZXggPSAkKGl0ZW0pLmNoaWxkcmVuKCkuZXEoaW5kZXhJblBhcmVudCk7XG4gICAgICAgIGlmIChjaGlsZEF0SW5kZXg/Lmxlbmd0aCkge1xuICAgICAgICAgIGNoaWxkQXRJbmRleC5iZWZvcmUobmV3RWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJChpdGVtKS5hcHBlbmQobmV3RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIG5hdiB0cmVlXG4gICAgICBhd2FpdCBidWlsZEFuZFNlbmROYXZUcmVlKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gICAgfVxuXG4gICAgdXBkYXRlT3V0bGluZXMocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgfTtcblxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy50ZW1wTW92ZVRvTmV3UGFyZW50ID0gKFxuICAgIHBhcmVudFBvcnQ6IGFueSxcbiAgICBzdG9yeWJvYXJkSWQ6IHN0cmluZyxcbiAgICBpbmRpY2F0b3JXaWR0aDogbnVtYmVyLFxuICAgIGluZGljYXRvckhlaWdodDogbnVtYmVyLFxuICAgIG5ld1Bvc2l0aW9uWDogbnVtYmVyLFxuICAgIG5ld1Bvc2l0aW9uWTogbnVtYmVyLFxuICAgIHBhcmVudEVsZW1lbnRLZXk6IHN0cmluZyxcbiAgICBjbGVhcjogYm9vbGVhbixcbiAgKSA9PiB7XG4gICAgJChgLiR7VEVNUE9fTU9WRV9CRVRXRUVOX1BBUkVOVFNfT1VUTElORX1gKS5yZW1vdmUoKTtcblxuICAgIGlmIChjbGVhcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBuZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoVEVNUE9fTU9WRV9CRVRXRUVOX1BBUkVOVFNfT1VUTElORSk7XG4gICAgbmV3RWxlbWVudC5zZXRBdHRyaWJ1dGUoVEVNUE9fSU5TVEFOVF9VUERBVEUsICd0cnVlJyk7IC8vIEFkZCBzbyBpdCBkb2Vzbid0IHRyaWdnZXIgbmV3IG5hdiB0cmVlIGJ1aWxkaW5nXG5cbiAgICBuZXdFbGVtZW50LnN0eWxlLndpZHRoID0gaW5kaWNhdG9yV2lkdGggKyAncHgnO1xuICAgIG5ld0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaW5kaWNhdG9ySGVpZ2h0ICsgJ3B4JztcbiAgICBuZXdFbGVtZW50LnN0eWxlLmxlZnQgPSBuZXdQb3NpdGlvblggKyAncHgnO1xuICAgIG5ld0VsZW1lbnQuc3R5bGUudG9wID0gbmV3UG9zaXRpb25ZICsgJ3B4JztcbiAgICBuZXdFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICBuZXdFbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgbmV3RWxlbWVudC5zdHlsZS56SW5kZXggPSAnMjAwMDAwMDAwNCc7XG4gICAgbmV3RWxlbWVudC5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gICAgbmV3RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCAhaW1wb3J0YW50JztcbiAgICBuZXdFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFBSSU1BUllfT1VUTElORV9DT0xPVVI7XG5cbiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcbiAgICBib2R5LmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpO1xuXG4gICAgY29uc3QgcGFyZW50RG9tRWxlbWVudCA9IGdldE5vZGVGb3JFbGVtZW50S2V5KHBhcmVudEVsZW1lbnRLZXkpO1xuXG4gICAgaWYgKHBhcmVudERvbUVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGJvdW5kaW5nUmVjdCA9IHBhcmVudERvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBwYXJlbnRPdXRsaW5lID0gZ2V0T3V0bGluZUVsZW1lbnQoXG4gICAgICAgIHBhcmVudFBvcnQsXG4gICAgICAgIE91dGxpbmVUeXBlLlBSSU1BUlksXG4gICAgICAgIGJvdW5kaW5nUmVjdC5sZWZ0LFxuICAgICAgICBib3VuZGluZ1JlY3QudG9wLFxuICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGgsXG4gICAgICAgIGJvdW5kaW5nUmVjdC5oZWlnaHQsXG4gICAgICApO1xuXG4gICAgICBwYXJlbnRPdXRsaW5lLmNsYXNzTGlzdC5yZW1vdmUoT1VUTElORV9DTEFTUyk7XG4gICAgICBwYXJlbnRPdXRsaW5lLmNsYXNzTGlzdC5hZGQoVEVNUE9fTU9WRV9CRVRXRUVOX1BBUkVOVFNfT1VUTElORSk7XG4gICAgICBwYXJlbnRPdXRsaW5lLnNldEF0dHJpYnV0ZShURU1QT19JTlNUQU5UX1VQREFURSwgJ3RydWUnKTsgLy8gQWRkIHNvIGl0IGRvZXNuJ3QgdHJpZ2dlciBuZXcgbmF2IHRyZWUgYnVpbGRpbmdcbiAgICAgIGJvZHkuYXBwZW5kQ2hpbGQocGFyZW50T3V0bGluZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEB0cy1pZ25vcmVcbiAgd2luZG93LmNoZWNrSWZIeWRyYXRpb25FcnJvciA9IChwYXJlbnRQb3J0OiBhbnksIHN0b3J5Ym9hcmRJZDogc3RyaW5nKSA9PiB7XG4gICAgbGV0IGVycm9yRGVzY3IsIGVycm9yTGFiZWwsIGVycm9yQm9keSwgaGFzRXJyb3I7XG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluY2x1ZGVzKCdmcmFtZXdvcms9VklURScpKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBlcnJvclBvcnRhbCA9XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd2aXRlLWVycm9yLW92ZXJsYXknKVswXT8uc2hhZG93Um9vdDtcblxuICAgICAgZXJyb3JEZXNjciA9ICdBIFZpdGUgRXJyb3IgT2NjdXJyZWQnO1xuICAgICAgZXJyb3JMYWJlbCA9XG4gICAgICAgIGVycm9yUG9ydGFsPy5xdWVyeVNlbGVjdG9yQWxsPy4oJy5maWxlLWxpbmsnKT8uWzBdPy5pbm5lckhUTUw7XG4gICAgICBlcnJvckJvZHkgPSBlcnJvclBvcnRhbD8ucXVlcnlTZWxlY3RvckFsbD8uKCcubWVzc2FnZScpPy5bMF0/LmlubmVySFRNTDtcbiAgICAgIGhhc0Vycm9yID0gQm9vbGVhbihlcnJvckxhYmVsIHx8IGVycm9yQm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IGVycm9yUG9ydGFsID1cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ25leHRqcy1wb3J0YWwnKVswXT8uc2hhZG93Um9vdDtcbiAgICAgIGVycm9yRGVzY3IgPSBlcnJvclBvcnRhbD8uZ2V0RWxlbWVudEJ5SWQ/LihcbiAgICAgICAgJ25leHRqc19fY29udGFpbmVyX2Vycm9yc19kZXNjJyxcbiAgICAgICk/LmlubmVySFRNTDtcbiAgICAgIGVycm9yTGFiZWwgPSBlcnJvclBvcnRhbD8uZ2V0RWxlbWVudEJ5SWQ/LihcbiAgICAgICAgJ25leHRqc19fY29udGFpbmVyX2Vycm9yc19sYWJlbCcsXG4gICAgICApPy5pbm5lckhUTUw7XG4gICAgICBlcnJvckJvZHkgPSBlcnJvclBvcnRhbD8ucXVlcnlTZWxlY3RvckFsbD8uKFxuICAgICAgICAnLm5leHRqcy1jb250YWluZXItZXJyb3JzLWJvZHknLFxuICAgICAgKT8uWzBdPy5pbm5lckhUTUw7XG4gICAgICBoYXNFcnJvciA9IEJvb2xlYW4oZXJyb3JEZXNjcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRlbnRzIG9mIHRoZSBoeWRyYXRpb24gY29udGFpbmVyIGNvbnRhaW4gdGhlIHRleHQgXCJIeWRyYXRpb24gZmFpbGVkXCJcbiAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgIGlmIChlcnJvckRlc2NyPy5pbmNsdWRlcygnSHlkcmF0aW9uIGZhaWxlZCcpKSB7XG4gICAgICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuTEFURVNUX0hZRFJBVElPTl9FUlJPUl9TVEFUVVMsXG4gICAgICAgICAgc3RhdHVzOiBTVE9SWUJPQVJEX0hZRFJBVElPTl9TVEFUVVMuRVJST1IsXG4gICAgICAgICAgZXJyb3JEZXNjcixcbiAgICAgICAgICBlcnJvckxhYmVsLFxuICAgICAgICAgIGVycm9yQm9keSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBpZDogRklYRURfSUZSQU1FX01FU1NBR0VfSURTLkxBVEVTVF9IWURSQVRJT05fRVJST1JfU1RBVFVTLFxuICAgICAgICAgIHN0YXR1czogU1RPUllCT0FSRF9IWURSQVRJT05fU1RBVFVTLk9USEVSX0VSUk9SLFxuICAgICAgICAgIGVycm9yRGVzY3IsXG4gICAgICAgICAgZXJyb3JMYWJlbCxcbiAgICAgICAgICBlcnJvckJvZHksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaWQ6IEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5MQVRFU1RfSFlEUkFUSU9OX0VSUk9SX1NUQVRVUyxcbiAgICAgICAgc3RhdHVzOiBTVE9SWUJPQVJEX0hZRFJBVElPTl9TVEFUVVMuTk9fRVJST1IsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cudHJpZ2dlckRyYWdTdGFydCA9IChwYXJlbnRQb3J0OiBhbnksIHN0b3J5Ym9hcmRJZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50S2V5ID0gZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oU0VMRUNURURfRUxFTUVOVF9LRVkpO1xuICAgIGNvbnN0IGVsZW1lbnRLZXlUb05hdk5vZGUgPVxuICAgICAgZ2V0TWVtb3J5U3RvcmFnZUl0ZW0oRUxFTUVOVF9LRVlfVE9fTkFWX05PREUpIHx8IHt9O1xuXG4gICAgLy8gU29tZXRoaW5nIGhhcyB0byBiZSBzZWxlY3RlZCB0byB0cmlnZ2VyIGEgZHJhZyBzdGFydFxuICAgIGlmICghc2VsZWN0ZWRFbGVtZW50S2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZHJhZ2dlZE5hdk5vZGUgPSBlbGVtZW50S2V5VG9OYXZOb2RlW3NlbGVjdGVkRWxlbWVudEtleV07XG5cbiAgICBjb25zdCBwYXJlbnREb21FbGVtZW50ID0gZ2V0UGFyZW50RG9tRWxlbWVudEZvck5hdk5vZGUoZHJhZ2dlZE5hdk5vZGUpO1xuXG4gICAgY29uc3QgbW91c2VEcmFnQ29udGV4dDogYW55ID0ge1xuICAgICAgLy8gU3RhcnQgb2ZmIHNjcmVlbiwgdGhpcyB3aWxsIGdldCB1cGRhdGVkIGJ5IG9uTW91c2VNb3ZlXG4gICAgICBwYWdlWDogLTEwMDAwLFxuICAgICAgcGFnZVk6IC0xMDAwMCxcblxuICAgICAgLy8gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB3aGVyZSB0aGUgdXNlciBjbGlja2VkIGFuZCB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50XG4gICAgICBvZmZzZXRYOiAwLFxuICAgICAgb2Zmc2V0WTogMCxcblxuICAgICAgZHJhZ2dpbmc6IHRydWUsXG5cbiAgICAgIHNlbGVjdGVkUGFyZW50RGlzcGxheTogY3NzRXZhbChwYXJlbnREb21FbGVtZW50LCAnZGlzcGxheScpLFxuICAgICAgc2VsZWN0ZWRQYXJlbnRGbGV4RGlyZWN0aW9uOiBjc3NFdmFsKHBhcmVudERvbUVsZW1lbnQsICdmbGV4LWRpcmVjdGlvbicpLFxuICAgIH07XG5cbiAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbSgnbW91c2VEcmFnQ29udGV4dCcsIG1vdXNlRHJhZ0NvbnRleHQpO1xuXG4gICAgLy8gVHJpZ2dlciB0aGUgZHJhZyBzdGFydCBldmVudFxuICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgaWQ6IEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5EUkFHX1NUQVJUX0VWRU5ULFxuICAgICAgZXZlbnQ6IG1vdXNlRHJhZ0NvbnRleHQsXG4gICAgICBvdXRlckhUTUw6IGdldEZ1bGxIdG1sV2l0aEVsZW1lbnQoW3NlbGVjdGVkRWxlbWVudEtleV0pLFxuICAgIH0pO1xuXG4gICAgdXBkYXRlT3V0bGluZXMocGFyZW50UG9ydCwgc3Rvcnlib2FyZElkKTtcbiAgfTtcblxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy50cmlnZ2VyRHJhZ0NhbmNlbCA9IChwYXJlbnRQb3J0OiBhbnksIHN0b3J5Ym9hcmRJZDogc3RyaW5nKSA9PiB7XG4gICAgc2V0TWVtb3J5U3RvcmFnZUl0ZW0oJ21vdXNlRHJhZ0NvbnRleHQnLCBudWxsKTtcblxuICAgIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgaWQ6IEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5EUkFHX0NBTkNFTF9FVkVOVCxcbiAgICAgIGV2ZW50OiB7fSxcbiAgICB9KTtcblxuICAgIHVwZGF0ZU91dGxpbmVzKHBhcmVudFBvcnQsIHN0b3J5Ym9hcmRJZCk7XG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuc2V0SXNGbHVzaGluZyA9IChcbiAgICBwYXJlbnRQb3J0OiBhbnksXG4gICAgc3Rvcnlib2FyZElkOiBzdHJpbmcsXG4gICAgaXNGbHVzaGluZzogYm9vbGVhbixcbiAgKSA9PiB7XG4gICAgY29uc3Qgd2FzRmx1c2hpbmcgPSBnZXRNZW1vcnlTdG9yYWdlSXRlbShJU19GTFVTSElORyk7XG5cbiAgICBzZXRNZW1vcnlTdG9yYWdlSXRlbShJU19GTFVTSElORywgaXNGbHVzaGluZyk7XG5cbiAgICBpZiAoaXNGbHVzaGluZyAmJiAhd2FzRmx1c2hpbmcpIHtcbiAgICAgIG9uRmx1c2hTdGFydCgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBAdHMtaWdub3JlXG4gIHdpbmRvdy5jYXB0dXJlQ29tcG9uZW50UHJldmlldyA9IGFzeW5jIChcbiAgICBwYXJlbnRQb3J0OiBhbnksXG4gICAgc3Rvcnlib2FyZElkOiBzdHJpbmcsXG4gICAgY29tcG9uZW50S2V5OiBzdHJpbmcsXG4gICAgY29kZWJhc2VJZDogc3RyaW5nLFxuICApID0+IHtcbiAgICAvLyBFeHRyYWN0IGNhbnZhcyBJRCBmcm9tIHRoZSBjdXJyZW50IFVSTCBwYXRoXG4gICAgbGV0IGNhbnZhc0lkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybFBhdGggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICBjb25zdCBjYW52YXNNYXRjaCA9IHVybFBhdGgubWF0Y2goL1xcL2NhbnZhc1xcLyhbXlxcL10rKS8pO1xuICAgICAgY2FudmFzSWQgPSBjYW52YXNNYXRjaCA/IGNhbnZhc01hdGNoWzFdIDogdW5kZWZpbmVkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBleHRyYWN0IGNhbnZhcyBJRCBmcm9tIFVSTDonLCBlcnJvcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyBXYWl0IGZvciB0aGUgcGFnZSB0byBiZSBmdWxseSBsb2FkZWRcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgcmVzb2x2ZSh2b2lkIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9uTG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICAgICAgICAgIHJlc29sdmUodm9pZCAwKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRpbWVvdXQgaW4gY2FzZSBsb2FkIGV2ZW50IGRvZXNuJ3QgZmlyZVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgICAgICAgICAgcmVzb2x2ZSh2b2lkIDApO1xuICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gRmluZCB0aGUgY29tcG9uZW50IGVsZW1lbnQgdG8gY2FwdHVyZVxuICAgICAgbGV0IHRhcmdldEVsZW1lbnQgPSBudWxsO1xuXG4gICAgICBpZiAoY29tcG9uZW50S2V5KSB7XG4gICAgICAgIHRhcmdldEVsZW1lbnQgPSBnZXROb2RlRm9yRWxlbWVudEtleShjb21wb25lbnRLZXkpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlYmFzZUlkKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvZGViYXNlIElEIHNlbGVjdG9yXG4gICAgICAgIHRhcmdldEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAuJHtjb2RlYmFzZUlkfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gZmluZGluZyB0aGUgZmlyc3QgZWxlbWVudCB3aXRoIHRlbXBvZWxlbWVudGlkIGF0dHJpYnV0ZVxuICAgICAgICB0YXJnZXRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW3RlbXBvZWxlbWVudGlkXScpO1xuXG4gICAgICAgIGlmICghdGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgIC8vIEZpbmFsIGZhbGxiYWNrIHRvIG1haW4gY29udGVudCBhcmVhXG4gICAgICAgICAgdGFyZ2V0RWxlbWVudCA9XG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS10ZW1wby1yb290XScpIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBhY3R1YWwgZGltZW5zaW9ucyBvZiB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgIGNvbnN0IHJlY3QgPSB0YXJnZXRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgZWxlbWVudFdpZHRoID0gTWF0aC5tYXgocmVjdC53aWR0aCwgODApOyAvLyBNaW5pbXVtIHdpZHRoIG9mIDgwcHhcbiAgICAgIGNvbnN0IGVsZW1lbnRIZWlnaHQgPSBNYXRoLm1heChyZWN0LmhlaWdodCwgNjApOyAvLyBNaW5pbXVtIGhlaWdodCBvZiA2MHB4XG5cbiAgICAgIGNvbnN0IG1heFdpZHRoID0gODAwO1xuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gNjAwO1xuICAgICAgY29uc3QgY2FwdHVyZVdpZHRoID0gTWF0aC5taW4oZWxlbWVudFdpZHRoLCBtYXhXaWR0aCk7XG4gICAgICBjb25zdCBjYXB0dXJlSGVpZ2h0ID0gTWF0aC5taW4oZWxlbWVudEhlaWdodCwgbWF4SGVpZ2h0KTtcblxuICAgICAgLy8gQ29uZmlndXJlIGNhcHR1cmUgb3B0aW9ucyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBxdWFsaXR5XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBxdWFsaXR5OiAwLjgsXG4gICAgICAgIHBpeGVsUmF0aW86IDIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICB3aWR0aDogY2FwdHVyZVdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhcHR1cmVIZWlnaHQsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknLFxuICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ3RvcCBsZWZ0JyxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gT3B0aW1pemVkIGZpbHRlciB0byBleGNsdWRlIHByb2JsZW1hdGljIGVsZW1lbnRzXG4gICAgICAgIGZpbHRlcjogKG5vZGU6IGFueSkgPT4ge1xuICAgICAgICAgIC8vIFNraXAgc2NyaXB0IHRhZ3MsIHN0eWxlcywgYW5kIGludmlzaWJsZSBlbGVtZW50c1xuICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT09ICdTQ1JJUFQnIHx8IG5vZGUudGFnTmFtZSA9PT0gJ1NUWUxFJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZpbHRlciBvdXQgb3V0bGluZSBlbGVtZW50cyBhbmQgb3RoZXIgVUkgb3ZlcmxheXNcbiAgICAgICAgICBpZiAobm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICFub2RlLmNsYXNzTGlzdC5jb250YWlucygndGVtcG8tb3V0bGluZScpICYmXG4gICAgICAgICAgICAgICFub2RlLmNsYXNzTGlzdC5jb250YWlucygndGVtcG8tdWktb3ZlcmxheScpICYmXG4gICAgICAgICAgICAgICFub2RlLmNsYXNzTGlzdC5jb250YWlucyhURU1QT19JTlNUQU5UX0RJVl9EUkFXX0NMQVNTKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNraXAgZXh0ZXJuYWwgcmVzb3VyY2VzIHRvIGF2b2lkIG5ldHdvcmsgZGVsYXlzXG4gICAgICAgIHNraXBGb250czogdHJ1ZSwgLy8gU2tpcCBmb250cyB0byBhdm9pZCBmb250IGxvYWRpbmcgcmVxdWVzdHNcbiAgICAgICAgZmV0Y2hSZXF1ZXN0SW5pdDoge1xuICAgICAgICAgIG1vZGU6ICduby1jb3JzJyBhcyBSZXF1ZXN0TW9kZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGRhdGFVcmwgPSBhd2FpdCB0b0pwZWcodGFyZ2V0RWxlbWVudCBhcyBIVE1MRWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFNlbmQgdGhlIGNhcHR1cmVkIGltYWdlIGJhY2sgdG8gdGhlIHBhcmVudFxuICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGlkOiBGSVhFRF9JRlJBTUVfTUVTU0FHRV9JRFMuQ09NUE9ORU5UX1BSRVZJRVdfQ0FQVFVSRUQsXG4gICAgICAgIGltYWdlRGF0YVVybDogZGF0YVVybCxcbiAgICAgICAgY29tcG9uZW50S2V5LFxuICAgICAgICBjb2RlYmFzZUlkLFxuICAgICAgICBzdG9yeWJvYXJkSWQsXG4gICAgICAgIGNhbnZhc0lkLCAvLyBJbmNsdWRlIGNhbnZhcyBJRCBmb3IgZGV0ZXJtaW5pc3RpYyBzdG9yYWdlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFtDQVBUVVJFXSBGYWlsZWQgdG8gY2FwdHVyZSBjb21wb25lbnQgcHJldmlldzonLCBlcnJvcik7XG5cbiAgICAgIC8vIFNlbmQgZXJyb3IgbWVzc2FnZSBiYWNrXG4gICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaWQ6IEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5DT01QT05FTlRfUFJFVklFV19FUlJPUixcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBlcnJvcjogZXJyb3I/Lm1lc3NhZ2UsXG4gICAgICAgIGNvbXBvbmVudEtleSxcbiAgICAgICAgY29kZWJhc2VJZCxcbiAgICAgICAgc3Rvcnlib2FyZElkLFxuICAgICAgICBjYW52YXNJZCwgLy8gSW5jbHVkZSBjYW52YXMgSUQgZm9yIGVycm9yIHRyYWNraW5nXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuIl19